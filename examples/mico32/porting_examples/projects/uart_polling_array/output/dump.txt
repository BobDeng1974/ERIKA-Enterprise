
output/out.elf:     file format elf32-lm32

Disassembly of section .boot:

02000000 <_reset_handler>:
#define ALL_LEDS ((unsigned int)(~0xFF))
#define NONE_LED ((unsigned int)(0xFF))

/* User functions */
void write_led(volatile unsigned int led)		// Function to turn on the leds 
{
 2000000:	98 00 00 00 	xor r0,r0,r0


#ifndef __STATIC_ISR_TABLE__

void EE_mico32_register_ISR(int level, EE_mico32_ISR_handler fun)
{
 2000004:	d0 00 00 00 	wcsr IE,r0
	return EE_UART_OK;
}

/* This functions sets rx callback */
int EE_hal_uart_set_rx_callback(EE_uart_st* usp, EE_ISR_callback isr_rx_callback)
{
 2000008:	d0 20 00 00 	wcsr IM,r0
/******************************************************************************/
/*                             Buffer Management                              */
/******************************************************************************/

int EE_buffer_init(EE_buffer *buf, int msgsize, int bufsize, EE_UINT8 *vet)
{
 200000c:	78 01 02 00 	mvhi r1,0x200
 2000010:	38 21 00 00 	ori r1,r1,0x0
 2000014:	d0 e1 00 00 	wcsr EBA,r1
 2000018:	f8 00 00 3a 	calli 2000100 <_crt0>
 200001c:	34 00 00 00 	nop

02000020 <_breakpoint_handler>:
 2000020:	91 20 38 00 	rcsr r7,DEBA
 2000024:	34 e7 00 20 	addi r7,r7,32
 2000028:	c0 e0 00 00 	b r7
 200002c:	34 00 00 00 	nop
 2000030:	34 00 00 00 	nop
 2000034:	34 00 00 00 	nop
 2000038:	34 00 00 00 	nop
 200003c:	34 00 00 00 	nop

02000040 <_instruction_bus_error_handler>:
 2000040:	91 20 38 00 	rcsr r7,DEBA
 2000044:	34 e7 00 40 	addi r7,r7,64
 2000048:	c0 e0 00 00 	b r7
 200004c:	34 00 00 00 	nop
 2000050:	34 00 00 00 	nop
 2000054:	34 00 00 00 	nop
 2000058:	34 00 00 00 	nop
 200005c:	34 00 00 00 	nop

02000060 <_watchpoint_handler>:
 2000060:	91 20 38 00 	rcsr r7,DEBA
 2000064:	34 e7 00 60 	addi r7,r7,96
 2000068:	c0 e0 00 00 	b r7
 200006c:	34 00 00 00 	nop
 2000070:	34 00 00 00 	nop
 2000074:	34 00 00 00 	nop
 2000078:	34 00 00 00 	nop
 200007c:	34 00 00 00 	nop

02000080 <_data_bus_error_handler>:
 2000080:	91 20 38 00 	rcsr r7,DEBA
 2000084:	34 e7 00 80 	addi r7,r7,128
 2000088:	c0 e0 00 00 	b r7
 200008c:	34 00 00 00 	nop
 2000090:	34 00 00 00 	nop
 2000094:	34 00 00 00 	nop
 2000098:	34 00 00 00 	nop
 200009c:	34 00 00 00 	nop

020000a0 <_divide_by_zero_handler>:
 20000a0:	91 20 38 00 	rcsr r7,DEBA
 20000a4:	34 e7 00 a0 	addi r7,r7,160
 20000a8:	c0 e0 00 00 	b r7
 20000ac:	34 00 00 00 	nop
 20000b0:	34 00 00 00 	nop
 20000b4:	34 00 00 00 	nop
 20000b8:	34 00 00 00 	nop
 20000bc:	34 00 00 00 	nop

020000c0 <_interrupt_handler>:
 20000c0:	5b 9d 00 00 	sw (sp+0),ra
 20000c4:	f8 00 00 21 	calli 2000148 <_save_all>
 20000c8:	34 01 00 02 	mvi r1,2
 20000cc:	f8 00 00 84 	calli 20002dc <MicoISRHandler>
 20000d0:	e0 00 00 33 	bi 200019c <_restore_all_and_return>
 20000d4:	34 00 00 00 	nop
 20000d8:	34 00 00 00 	nop
 20000dc:	34 00 00 00 	nop

020000e0 <_system_call_handler>:
 20000e0:	91 20 38 00 	rcsr r7,DEBA
 20000e4:	34 e7 00 e0 	addi r7,r7,224
 20000e8:	c0 e0 00 00 	b r7
 20000ec:	34 00 00 00 	nop
 20000f0:	34 00 00 00 	nop
 20000f4:	34 00 00 00 	nop
 20000f8:	34 00 00 00 	nop
 20000fc:	34 00 00 00 	nop

02000100 <_crt0>:
 2000100:	98 00 00 00 	xor r0,r0,r0
 2000104:	78 1c 02 07 	mvhi sp,0x207
 2000108:	3b 9c ff fc 	ori sp,sp,0xfffc
 200010c:	78 1a 02 00 	mvhi gp,0x200
 2000110:	3b 5a 91 50 	ori gp,gp,0x9150
 2000114:	78 01 02 00 	mvhi r1,0x200
 2000118:	38 21 11 54 	ori r1,r1,0x1154
 200011c:	78 03 02 00 	mvhi r3,0x200
 2000120:	38 63 11 f4 	ori r3,r3,0x11f4

02000124 <.ClearBSS>:
 2000124:	e0 00 00 03 	bi 2000130 <.ClearBSS+0xc>
 2000128:	58 20 00 00 	sw (r1+0),r0
 200012c:	34 21 00 04 	addi r1,r1,4
 2000130:	5c 23 ff fe 	bne r1,r3,2000128 <.ClearBSS+0x4>

02000134 <.CallConstructor>:
 2000134:	34 01 00 00 	mvi r1,0
 2000138:	34 02 00 00 	mvi r2,0
 200013c:	34 03 00 00 	mvi r3,0
 2000140:	f8 00 00 61 	calli 20002c4 <LatticeDDInit>
 2000144:	f8 00 03 4b 	calli 2000e70 <_exit>

02000148 <_save_all>:
 2000148:	37 9c ff c4 	addi sp,sp,-60
 200014c:	5b 81 00 04 	sw (sp+4),r1
 2000150:	5b 82 00 08 	sw (sp+8),r2
 2000154:	5b 83 00 0c 	sw (sp+12),r3
 2000158:	5b 84 00 10 	sw (sp+16),r4
 200015c:	5b 85 00 14 	sw (sp+20),r5
 2000160:	5b 86 00 18 	sw (sp+24),r6
 2000164:	5b 87 00 1c 	sw (sp+28),r7
 2000168:	5b 88 00 20 	sw (sp+32),r8
 200016c:	5b 89 00 24 	sw (sp+36),r9
 2000170:	5b 8a 00 28 	sw (sp+40),r10
 2000174:	5b 9e 00 34 	sw (sp+52),ea
 2000178:	5b 9f 00 38 	sw (sp+56),ba
 200017c:	2b 81 00 3c 	lw r1,(sp+60)
 2000180:	5b 81 00 30 	sw (sp+48),r1
 2000184:	bb 80 08 00 	mv r1,sp
 2000188:	34 21 00 3c 	addi r1,r1,60
 200018c:	5b 81 00 2c 	sw (sp+44),r1
 2000190:	98 21 08 00 	xor r1,r1,r1
 2000194:	d0 01 00 00 	wcsr IE,r1
 2000198:	c3 a0 00 00 	ret

0200019c <_restore_all_and_return>:
 200019c:	34 01 00 02 	mvi r1,2
 20001a0:	d0 01 00 00 	wcsr IE,r1
 20001a4:	2b 81 00 04 	lw r1,(sp+4)
 20001a8:	2b 82 00 08 	lw r2,(sp+8)
 20001ac:	2b 83 00 0c 	lw r3,(sp+12)
 20001b0:	2b 84 00 10 	lw r4,(sp+16)
 20001b4:	2b 85 00 14 	lw r5,(sp+20)
 20001b8:	2b 86 00 18 	lw r6,(sp+24)
 20001bc:	2b 87 00 1c 	lw r7,(sp+28)
 20001c0:	2b 88 00 20 	lw r8,(sp+32)
 20001c4:	2b 89 00 24 	lw r9,(sp+36)
 20001c8:	2b 8a 00 28 	lw r10,(sp+40)
 20001cc:	2b 9d 00 30 	lw ra,(sp+48)
 20001d0:	2b 9e 00 34 	lw ea,(sp+52)
 20001d4:	2b 9f 00 38 	lw ba,(sp+56)
 20001d8:	2b 9c 00 2c 	lw sp,(sp+44)
 20001dc:	34 00 00 00 	nop
 20001e0:	c3 c0 00 00 	eret
Disassembly of section .text:

020001e4 <main>:

/*
 * MAIN TASK
 */
int main(void)
{
 20001e4:	37 9c ff f8 	addi sp,sp,-8
 20001e8:	5b 8b 00 08 	sw (sp+8),r11
 20001ec:	5b 9d 00 04 	sw (sp+4),ra
 * Disable interrupts
 */
__INLINE__ EE_FREG __ALWAYS_INLINE__ EE_mico32_disableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 20001f0:	90 00 08 00 	rcsr r1,IE
    newie = oldie & (~0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 20001f4:	34 02 ff fe 	mvi r2,-2
 20001f8:	a0 22 08 00 	and r1,r1,r2
 20001fc:	d0 01 00 00 	wcsr IE,r1

/* User functions */
void write_led(volatile unsigned int led)		// Function to turn on the leds 
{
    MicoGPIO_t *ledc = (MicoGPIO_t *)LED_BASE_ADDRESS;
    ledc->data = (EE_UINT8)led;
 2000200:	78 02 80 00 	mvhi r2,0x8000
 2000204:	38 42 00 80 	ori r2,r2,0x80
 2000208:	78 0b 00 01 	mvhi r11,0x1
 200020c:	34 01 00 ff 	mvi r1,255
 2000210:	58 41 00 00 	sw (r2+0),r1
	EE_uart_set_mode(EE_UART_POLLING);	// no blocking mode
	#endif

	while(1)
	{	
		for(i=0;i<100000;i++);
 2000214:	39 6b 86 9f 	ori r11,r11,0x869f

/* User functions */
void write_led(volatile unsigned int led)		// Function to turn on the leds 
{
    MicoGPIO_t *ledc = (MicoGPIO_t *)LED_BASE_ADDRESS;
    ledc->data = (EE_UINT8)led;
 2000218:	34 02 00 00 	mvi r2,0
	#endif

	while(1)
	{	
		for(i=0;i<100000;i++);
  		ActivateTask(Task1);
 200021c:	34 01 00 00 	mvi r1,0
	EE_uart_set_mode(EE_UART_POLLING);	// no blocking mode
	#endif

	while(1)
	{	
		for(i=0;i<100000;i++);
 2000220:	4d 62 00 06 	bge r11,r2,2000238 <_ftext_rom+0x54>
  		ActivateTask(Task1);
 2000224:	f8 00 00 f2 	calli 20005ec <EE_fp_ActivateTask>
 2000228:	34 02 00 00 	mvi r2,0
 200022c:	34 01 00 00 	mvi r1,0
	EE_uart_set_mode(EE_UART_POLLING);	// no blocking mode
	#endif

	while(1)
	{	
		for(i=0;i<100000;i++);
 2000230:	4d 62 00 02 	bge r11,r2,2000238 <_ftext_rom+0x54>
 2000234:	e3 ff ff fc 	bi 2000224 <_ftext_rom+0x40>
 2000238:	34 42 00 01 	addi r2,r2,1
 200023c:	e3 ff ff f8 	bi 200021c <_ftext_rom+0x38>

02000240 <FuncTask1>:

/*
 * Task 1
 */
TASK(Task1)
{
 2000240:	37 9c ff f4 	addi sp,sp,-12
 2000244:	5b 8b 00 08 	sw (sp+8),r11
 2000248:	5b 9d 00 04 	sw (sp+4),ra
	return EE_hal_uart_return_error(& EE_ST_NAME(lc)); }
	
/* User functions (API): */  
#ifdef EE_UART1_NAME_UC
DECLARE_STRUCT_UART(EE_UART1_NAME_UC, EE_UART1_NAME_LC)
DECLARE_FUNC_UART(EE_UART1_NAME_UC, EE_UART1_NAME_LC)
 200024c:	78 01 02 00 	mvhi r1,0x200
 2000250:	38 21 11 0c 	ori r1,r1,0x110c
 2000254:	37 82 00 0c 	addi r2,sp,12
 2000258:	34 03 00 03 	mvi r3,3
 200025c:	f8 00 01 ee 	calli 2000a14 <EE_hal_uart_read_buffer>
    EE_UINT8 uart_byte[3];
    
 	if( EE_uart_read_buffer(uart_byte,3) < 0 )
 2000260:	4c 20 00 09 	bge r1,r0,2000284 <FuncTask1+0x44>

/* User functions */
void write_led(volatile unsigned int led)		// Function to turn on the leds 
{
    MicoGPIO_t *ledc = (MicoGPIO_t *)LED_BASE_ADDRESS;
    ledc->data = (EE_UINT8)led;
 2000264:	78 01 80 00 	mvhi r1,0x8000
 2000268:	38 21 00 80 	ori r1,r1,0x80
 200026c:	34 02 00 fd 	mvi r2,253
 2000270:	58 22 00 00 	sw (r1+0),r2
    		/* Turn on ERROR led */
    		write_led(LED3);
    	}
    }

}
 2000274:	2b 9d 00 04 	lw ra,(sp+4)
 2000278:	2b 8b 00 08 	lw r11,(sp+8)
 200027c:	37 9c 00 0c 	addi sp,sp,12
 2000280:	c3 a0 00 00 	ret

/* User functions */
void write_led(volatile unsigned int led)		// Function to turn on the leds 
{
    MicoGPIO_t *ledc = (MicoGPIO_t *)LED_BASE_ADDRESS;
    ledc->data = (EE_UINT8)led;
 2000284:	78 0b 80 00 	mvhi r11,0x8000
 2000288:	34 02 00 ff 	mvi r2,255
 200028c:	39 6b 00 80 	ori r11,r11,0x80
 2000290:	78 01 02 00 	mvhi r1,0x200
 2000294:	59 62 00 00 	sw (r11+0),r2
 2000298:	38 21 11 0c 	ori r1,r1,0x110c
 200029c:	37 82 00 0c 	addi r2,sp,12
 20002a0:	34 03 00 03 	mvi r3,3
 20002a4:	f8 00 01 3d 	calli 2000798 <EE_hal_uart_write_buffer>
    	write_led(LED2);
    }
    else
    { 
    	write_led(NONE_LED);
    	if( EE_uart_write_buffer(uart_byte,3) < 0 )
 20002a8:	4c 20 ff f3 	bge r1,r0,2000274 <FuncTask1+0x34>

/* User functions */
void write_led(volatile unsigned int led)		// Function to turn on the leds 
{
    MicoGPIO_t *ledc = (MicoGPIO_t *)LED_BASE_ADDRESS;
    ledc->data = (EE_UINT8)led;
 20002ac:	34 01 00 fb 	mvi r1,251
 20002b0:	59 61 00 00 	sw (r11+0),r1
    		/* Turn on ERROR led */
    		write_led(LED3);
    	}
    }

}
 20002b4:	2b 9d 00 04 	lw ra,(sp+4)
 20002b8:	2b 8b 00 08 	lw r11,(sp+8)
 20002bc:	37 9c 00 0c 	addi sp,sp,12
 20002c0:	c3 a0 00 00 	ret

020002c4 <LatticeDDInit>:
//  
/////////////////////////////////////////////////////////////////////////////
    #include "DDStructs.h"

    void LatticeDDInit(void)
    {
 20002c4:	37 9c ff fc 	addi sp,sp,-4
 20002c8:	5b 9d 00 04 	sw (sp+4),ra
        LatticeMico32Init(&lm32_top_LM32);
        // Needed only to use the Jtag interface for I/O
#endif

        // Invoke application's main routine
        main();
 20002cc:	fb ff ff c6 	calli 20001e4 <_ftext_rom>
    }
 20002d0:	2b 9d 00 04 	lw ra,(sp+4)
 20002d4:	37 9c 00 04 	addi sp,sp,4
 20002d8:	c3 a0 00 00 	ret

020002dc <MicoISRHandler>:


/* Possible improvement: Enable higher-level interrupts while processing lower
 * level interrupts, even in this function */
void MicoISRHandler(void)
{
 20002dc:	37 9c ff f0 	addi sp,sp,-16
 20002e0:	5b 8b 00 10 	sw (sp+16),r11
 20002e4:	5b 8c 00 0c 	sw (sp+12),r12
 20002e8:	5b 8d 00 08 	sw (sp+8),r13
 20002ec:	5b 9d 00 04 	sw (sp+4),ra
    EE_increment_IRQ_nesting_level();
 20002f0:	78 0d 02 00 	mvhi r13,0x200
 20002f4:	39 ad 11 ec 	ori r13,r13,0x11ec
 20002f8:	34 01 00 01 	mvi r1,1
 20002fc:	59 a1 00 00 	sw (r13+0),r1


__INLINE__ int __ALWAYS_INLINE__ mico32_get_reg_ip(void)
{
    int ip;
    asm volatile ( "rcsr %0,ip":"=r"(ip) );
 2000300:	90 40 10 00 	rcsr r2,IP


__INLINE__ int __ALWAYS_INLINE__ mico32_get_reg_im(void)
{
    int im;
    asm volatile ( "rcsr %0,im":"=r"(im) );
 2000304:	90 20 08 00 	rcsr r1,IM
    int im, ip;

    for (;;) {
        ip = mico32_get_reg_ip();
        im = mico32_get_reg_im();
        ip &= im;
 2000308:	a0 41 10 00 	and r2,r2,r1
        if (ip == 0)
 200030c:	44 40 00 15 	be r2,r0,2000360 <MicoISRHandler+0x84>
 2000310:	78 0c 02 00 	mvhi r12,0x200
 2000314:	39 8c 11 64 	ori r12,r12,0x1164
 2000318:	20 43 00 01 	andi r3,r2,0x1
 200031c:	34 0b 00 01 	mvi r11,1
            break;
        for (mask = 1, level = 0; ; ++level, mask <<= 1) {
            if (ip & mask) {
 2000320:	5c 60 00 29 	bne r3,r0,20003c4 <MicoISRHandler+0xe8>
        ip = mico32_get_reg_ip();
        im = mico32_get_reg_im();
        ip &= im;
        if (ip == 0)
            break;
        for (mask = 1, level = 0; ; ++level, mask <<= 1) {
 2000324:	b5 6b 58 00 	add r11,r11,r11
            if (ip & mask) {
 2000328:	a1 62 08 00 	and r1,r11,r2
        ip = mico32_get_reg_ip();
        im = mico32_get_reg_im();
        ip &= im;
        if (ip == 0)
            break;
        for (mask = 1, level = 0; ; ++level, mask <<= 1) {
 200032c:	34 63 00 01 	addi r3,r3,1
            if (ip & mask) {
 2000330:	44 20 ff fd 	be r1,r0,2000324 <MicoISRHandler+0x48>
                EE_mico32_ISR_handler f = EE_mico32_ISR_table[level];
 2000334:	3c 61 00 02 	sli r1,r3,2
 2000338:	b5 81 08 00 	add r1,r12,r1
 200033c:	28 22 00 00 	lw r2,(r1+0)
                if (f)
 2000340:	44 40 00 03 	be r2,r0,200034c <MicoISRHandler+0x70>
*/
#else /* __IRQ_STACK_NEEDED__ is defined */
__INLINE__ void __ALWAYS_INLINE__ EE_mico32_call_ISR_new_stack(int irq_level, EE_mico32_ISR_handler fun, int nesting_level)
{
    EE_std_enableIRQ_nested(); /* Enable IRQ if nesting is allowed */
    fun(irq_level);
 2000344:	b8 60 08 00 	mv r1,r3
 2000348:	d8 40 00 00 	call r2
}


__INLINE__ void __ALWAYS_INLINE__ mico32_clear_ip_mask(int mask)
{
    asm volatile ( "wcsr ip,%0"::"r"(mask) );
 200034c:	d0 4b 00 00 	wcsr IP,r11


__INLINE__ int __ALWAYS_INLINE__ mico32_get_reg_ip(void)
{
    int ip;
    asm volatile ( "rcsr %0,ip":"=r"(ip) );
 2000350:	90 40 10 00 	rcsr r2,IP


__INLINE__ int __ALWAYS_INLINE__ mico32_get_reg_im(void)
{
    int im;
    asm volatile ( "rcsr %0,im":"=r"(im) );
 2000354:	90 20 08 00 	rcsr r1,IM
    int im, ip;

    for (;;) {
        ip = mico32_get_reg_ip();
        im = mico32_get_reg_im();
        ip &= im;
 2000358:	a0 22 10 00 	and r2,r1,r2
        if (ip == 0)
 200035c:	5c 40 ff ef 	bne r2,r0,2000318 <MicoISRHandler+0x3c>
                mico32_clear_ip_mask(mask);
                break;
            }
        }
    }
    EE_decrement_IRQ_nesting_level();
 2000360:	34 01 00 00 	mvi r1,0
 2000364:	59 a1 00 00 	sw (r13+0),r1
 * the scheduler and launch a new scheduled task (if any), or change the current
 * stack (if needed); return whenever there is nothing else to do.
 */
__INLINE__ void __ALWAYS_INLINE__ EE_std_after_IRQ_schedule(void)
{
    EE_IRQ_end_instance();
 2000368:	f8 00 00 57 	calli 20004c4 <EE_IRQ_end_instance>
    if (EE_std_need_context_change(EE_std_endcycle_next_tid))
 200036c:	78 01 02 00 	mvhi r1,0x200
 2000370:	38 21 11 f0 	ori r1,r1,0x11f0
 2000374:	28 25 00 00 	lw r5,(r1+0)
 2000378:	4c a0 00 0b 	bge r5,r0,20003a4 <MicoISRHandler+0xc8>
 200037c:	34 a3 00 01 	addi r3,r5,1
 2000380:	3c 63 00 02 	sli r3,r3,2
 2000384:	78 01 02 00 	mvhi r1,0x200
 2000388:	38 21 0e 84 	ori r1,r1,0xe84
 200038c:	78 02 02 00 	mvhi r2,0x200
 2000390:	b4 23 08 00 	add r1,r1,r3
 2000394:	38 42 11 58 	ori r2,r2,0x1158
 2000398:	28 24 00 00 	lw r4,(r1+0)
 200039c:	28 43 00 00 	lw r3,(r2+0)
 20003a0:	44 83 00 03 	be r4,r3,20003ac <MicoISRHandler+0xd0>
        EE_std_change_context(EE_std_endcycle_next_tid);
 20003a4:	b8 a0 08 00 	mv r1,r5
 20003a8:	f8 00 00 09 	calli 20003cc <EE_std_change_context>
        /* Outer nesting level: call the scheduler.  If we have also type-ISR1
         * interrupts, the scheduler should be called only for type-ISR2
         * interrupts. */
        EE_std_after_IRQ_schedule();
    }
}
 20003ac:	2b 9d 00 04 	lw ra,(sp+4)
 20003b0:	2b 8b 00 10 	lw r11,(sp+16)
 20003b4:	2b 8c 00 0c 	lw r12,(sp+12)
 20003b8:	2b 8d 00 08 	lw r13,(sp+8)
 20003bc:	37 9c 00 10 	addi sp,sp,16
 20003c0:	c3 a0 00 00 	ret
        im = mico32_get_reg_im();
        ip &= im;
        if (ip == 0)
            break;
        for (mask = 1, level = 0; ; ++level, mask <<= 1) {
            if (ip & mask) {
 20003c4:	34 03 00 00 	mvi r3,0
 20003c8:	e3 ff ff db 	bi 2000334 <MicoISRHandler+0x58>

020003cc <EE_std_change_context>:
 20003cc:	3c 22 00 02 	sli r2,r1,2
 20003d0:	78 03 02 00 	mvhi r3,0x200
 20003d4:	38 63 0e 84 	ori r3,r3,0xe84
 20003d8:	b4 62 10 00 	add r2,r3,r2
 20003dc:	28 42 00 04 	lw r2,(r2+4)
 20003e0:	78 03 02 00 	mvhi r3,0x200
 20003e4:	38 63 11 58 	ori r3,r3,0x1158
 20003e8:	28 64 00 00 	lw r4,(r3+0)
 20003ec:	44 44 00 2e 	be r2,r4,20004a4 <_end_change_stacks>
 20003f0:	5b 9d ff bc 	sw (sp+-68),ra
 20003f4:	5b 9b ff c0 	sw (sp+-64),fp
 20003f8:	5b 9a ff c4 	sw (sp+-60),gp
 20003fc:	5b 99 ff c8 	sw (sp+-56),r25
 2000400:	5b 98 ff cc 	sw (sp+-52),r24
 2000404:	5b 97 ff d0 	sw (sp+-48),r23
 2000408:	5b 96 ff d4 	sw (sp+-44),r22
 200040c:	5b 95 ff d8 	sw (sp+-40),r21
 2000410:	5b 94 ff dc 	sw (sp+-36),r20
 2000414:	5b 93 ff e0 	sw (sp+-32),r19
 2000418:	5b 92 ff e4 	sw (sp+-28),r18
 200041c:	5b 91 ff e8 	sw (sp+-24),r17
 2000420:	5b 90 ff ec 	sw (sp+-20),r16
 2000424:	5b 8f ff f0 	sw (sp+-16),r15
 2000428:	5b 8e ff f4 	sw (sp+-12),r14
 200042c:	5b 8d ff f8 	sw (sp+-8),r13
 2000430:	5b 8c ff fc 	sw (sp+-4),r12
 2000434:	5b 8b 00 00 	sw (sp+0),r11
 2000438:	78 05 02 00 	mvhi r5,0x200
 200043c:	38 a5 11 04 	ori r5,r5,0x1104
 2000440:	3c 84 00 02 	sli r4,r4,2
 2000444:	b4 a4 20 00 	add r4,r5,r4
 2000448:	58 9c 00 00 	sw (r4+0),sp
 200044c:	58 62 00 00 	sw (r3+0),r2
 2000450:	3c 42 00 02 	sli r2,r2,2
 2000454:	b4 a2 10 00 	add r2,r5,r2
 2000458:	28 5c 00 00 	lw sp,(r2+0)
 200045c:	2b 9d ff bc 	lw ra,(sp+-68)
 2000460:	2b 9b ff c0 	lw fp,(sp+-64)
 2000464:	2b 9a ff c4 	lw gp,(sp+-60)
 2000468:	2b 99 ff c8 	lw r25,(sp+-56)
 200046c:	2b 98 ff cc 	lw r24,(sp+-52)
 2000470:	2b 97 ff d0 	lw r23,(sp+-48)
 2000474:	2b 96 ff d4 	lw r22,(sp+-44)
 2000478:	2b 95 ff d8 	lw r21,(sp+-40)
 200047c:	2b 94 ff dc 	lw r20,(sp+-36)
 2000480:	2b 93 ff e0 	lw r19,(sp+-32)
 2000484:	2b 92 ff e4 	lw r18,(sp+-28)
 2000488:	2b 91 ff e8 	lw r17,(sp+-24)
 200048c:	2b 90 ff ec 	lw r16,(sp+-20)
 2000490:	2b 8f ff f0 	lw r15,(sp+-16)
 2000494:	2b 8e ff f4 	lw r14,(sp+-12)
 2000498:	2b 8d ff f8 	lw r13,(sp+-8)
 200049c:	2b 8c ff fc 	lw r12,(sp+-4)
 20004a0:	2b 8b 00 00 	lw r11,(sp+0)

020004a4 <_end_change_stacks>:
 20004a4:	48 01 00 07 	bg r0,r1,20004c0 <_end_run_thread>
 20004a8:	37 9c ff fc 	addi sp,sp,-4
 20004ac:	5b 9d 00 04 	sw (sp+4),ra
 20004b0:	f8 00 01 d8 	calli 2000c10 <EE_std_run_task_code>
 20004b4:	2b 9d 00 04 	lw ra,(sp+4)
 20004b8:	37 9c 00 04 	addi sp,sp,4
 20004bc:	e3 ff ff c4 	bi 20003cc <EE_std_change_context>

020004c0 <_end_run_thread>:
 20004c0:	c3 a0 00 00 	ret

020004c4 <EE_IRQ_end_instance>:
   If the HAL allow IRQ nesting the C_end_instance should work as follows:
   - it must implement the preemption test only if it is the last IRQ on the stack
   - if there are other interrupts on the stack the IRQ end_instance should do nothing
*/
void EE_IRQ_end_instance(void)
{
 20004c4:	37 9c ff fc 	addi sp,sp,-4
 20004c8:	5b 9d 00 04 	sw (sp+4),ra

/* return the first ready task without extracting it */
#ifndef __PRIVATE_RQ_QUERYFIRST__
__INLINE__ EE_TID __ALWAYS_INLINE__ EE_rq_queryfirst(void)
{
    return EE_rqfirst;  
 20004cc:	78 01 02 00 	mvhi r1,0x200
 20004d0:	38 21 0e 98 	ori r1,r1,0xe98
 20004d4:	28 21 00 00 	lw r1,(r1+0)
    register EE_TID t;

    t = EE_rq_queryfirst();
    if (t != EE_NIL && EE_sys_ceiling < EE_th_ready_prio[t]) {
 20004d8:	34 02 ff ff 	mvi r2,-1
 20004dc:	44 22 00 22 	be r1,r2,2000564 <EE_IRQ_end_instance+0xa0>
 20004e0:	3c 24 00 02 	sli r4,r1,2
 20004e4:	78 01 02 00 	mvhi r1,0x200
 20004e8:	38 21 0e 7c 	ori r1,r1,0xe7c
 20004ec:	78 05 02 00 	mvhi r5,0x200
 20004f0:	38 a5 11 54 	ori r5,r5,0x1154
 20004f4:	b4 24 08 00 	add r1,r1,r4
 20004f8:	28 22 00 00 	lw r2,(r1+0)
 20004fc:	28 a6 00 00 	lw r6,(r5+0)
 2000500:	50 c2 00 19 	bgeu r6,r2,2000564 <EE_IRQ_end_instance+0xa0>
      register int flag;

      flag = EE_th_status[t] & EE_WASSTACKED;
#endif

      EE_sys_ceiling |= EE_th_dispatch_prio[t];
 2000504:	78 02 02 00 	mvhi r2,0x200
 2000508:	38 42 0e 80 	ori r2,r2,0xe80
    t = EE_rq_queryfirst();
    if (t != EE_NIL && EE_sys_ceiling < EE_th_ready_prio[t]) {
#if defined(__MULTI__)
      register int flag;

      flag = EE_th_status[t] & EE_WASSTACKED;
 200050c:	78 03 02 00 	mvhi r3,0x200
#endif

      EE_sys_ceiling |= EE_th_dispatch_prio[t];
 2000510:	b4 44 10 00 	add r2,r2,r4
    t = EE_rq_queryfirst();
    if (t != EE_NIL && EE_sys_ceiling < EE_th_ready_prio[t]) {
#if defined(__MULTI__)
      register int flag;

      flag = EE_th_status[t] & EE_WASSTACKED;
 2000514:	38 63 0e 8c 	ori r3,r3,0xe8c
 2000518:	b4 64 18 00 	add r3,r3,r4
#endif

      EE_sys_ceiling |= EE_th_dispatch_prio[t];
 200051c:	28 41 00 00 	lw r1,(r2+0)
    t = EE_rq_queryfirst();
    if (t != EE_NIL && EE_sys_ceiling < EE_th_ready_prio[t]) {
#if defined(__MULTI__)
      register int flag;

      flag = EE_th_status[t] & EE_WASSTACKED;
 2000520:	28 64 00 00 	lw r4,(r3+0)
#endif

      EE_sys_ceiling |= EE_th_dispatch_prio[t];

#if defined(__MULTI__) || defined(__WITH_STATUS__)
      EE_th_status[t] = EE_STACKED;
 2000524:	34 02 00 02 	mvi r2,2
      register int flag;

      flag = EE_th_status[t] & EE_WASSTACKED;
#endif

      EE_sys_ceiling |= EE_th_dispatch_prio[t];
 2000528:	b8 26 08 00 	or r1,r1,r6
 200052c:	58 a1 00 00 	sw (r5+0),r1

#if defined(__MULTI__) || defined(__WITH_STATUS__)
      EE_th_status[t] = EE_STACKED;
 2000530:	58 62 00 00 	sw (r3+0),r2
    t = EE_rq_queryfirst();
    if (t != EE_NIL && EE_sys_ceiling < EE_th_ready_prio[t]) {
#if defined(__MULTI__)
      register int flag;

      flag = EE_th_status[t] & EE_WASSTACKED;
 2000534:	20 84 00 08 	andi r4,r4,0x8
#if defined(__MULTI__) || defined(__WITH_STATUS__)
      EE_th_status[t] = EE_STACKED;
#endif

#if defined(__MULTI__)
      if (flag)
 2000538:	44 80 00 17 	be r4,r0,2000594 <EE_IRQ_end_instance+0xd0>
	EE_hal_IRQ_stacked(EE_rq2stk_exchange());
 200053c:	f8 00 00 1d 	calli 20005b0 <EE_rq2stk_exchange>
}


__INLINE__ void __ALWAYS_INLINE__ EE_hal_endcycle_stacked(EE_TID tid)
{
    EE_std_endcycle_next_tid = EE_std_mark_tid_stacked(tid);
 2000540:	78 02 80 00 	mvhi r2,0x8000
 2000544:	38 42 00 00 	ori r2,r2,0x0
 2000548:	78 03 02 00 	mvhi r3,0x200
 200054c:	b8 22 08 00 	or r1,r1,r2
 2000550:	38 63 11 f0 	ori r3,r3,0x11f0
 2000554:	58 61 00 00 	sw (r3+0),r1
      EE_hal_IRQ_ready(EE_rq2stk_exchange());
#endif
    } else {
      EE_hal_IRQ_stacked(EE_stk_queryfirst());
    }
}
 2000558:	2b 9d 00 04 	lw ra,(sp+4)
 200055c:	37 9c 00 04 	addi sp,sp,4
 2000560:	c3 a0 00 00 	ret
 2000564:	78 01 02 00 	mvhi r1,0x200
 2000568:	38 21 0e 94 	ori r1,r1,0xe94
 200056c:	28 23 00 00 	lw r3,(r1+0)
 2000570:	78 02 80 00 	mvhi r2,0x8000
 2000574:	38 42 00 00 	ori r2,r2,0x0
 2000578:	78 01 02 00 	mvhi r1,0x200
 200057c:	b8 62 18 00 	or r3,r3,r2
 2000580:	38 21 11 f0 	ori r1,r1,0x11f0
 2000584:	58 23 00 00 	sw (r1+0),r3
 2000588:	2b 9d 00 04 	lw ra,(sp+4)
 200058c:	37 9c 00 04 	addi sp,sp,4
 2000590:	c3 a0 00 00 	ret

#if defined(__MULTI__)
      if (flag)
	EE_hal_IRQ_stacked(EE_rq2stk_exchange());
      else
	EE_hal_IRQ_ready(EE_rq2stk_exchange());
 2000594:	f8 00 00 07 	calli 20005b0 <EE_rq2stk_exchange>
}


__INLINE__ void __ALWAYS_INLINE__ EE_hal_endcycle_ready(EE_TID tid)
{
    EE_std_endcycle_next_tid = tid;
 2000598:	78 02 02 00 	mvhi r2,0x200
 200059c:	38 42 11 f0 	ori r2,r2,0x11f0
 20005a0:	58 41 00 00 	sw (r2+0),r1
      EE_hal_IRQ_ready(EE_rq2stk_exchange());
#endif
    } else {
      EE_hal_IRQ_stacked(EE_stk_queryfirst());
    }
}
 20005a4:	2b 9d 00 04 	lw ra,(sp+4)
 20005a8:	37 9c 00 04 	addi sp,sp,4
 20005ac:	c3 a0 00 00 	ret

020005b0 <EE_rq2stk_exchange>:

#include "ee_internal.h"

#ifndef __PRIVATE_RQ2STK_EXCHANGE__
EE_TID EE_rq2stk_exchange(void)
{
 20005b0:	78 04 02 00 	mvhi r4,0x200
 20005b4:	38 84 0e 98 	ori r4,r4,0xe98
 20005b8:	28 81 00 00 	lw r1,(r4+0)
  EE_TID temp;

  temp = EE_rqfirst;
  
  // extract the first task from the ready queue
  EE_rqfirst = EE_th_next[temp]; 
 20005bc:	78 02 02 00 	mvhi r2,0x200
 20005c0:	38 42 0e 90 	ori r2,r2,0xe90
 20005c4:	3c 25 00 02 	sli r5,r1,2
  // insert the extracted task on the topo of the stack
  EE_th_next[temp] = EE_stkfirst;
 20005c8:	78 03 02 00 	mvhi r3,0x200
  EE_TID temp;

  temp = EE_rqfirst;
  
  // extract the first task from the ready queue
  EE_rqfirst = EE_th_next[temp]; 
 20005cc:	b4 45 10 00 	add r2,r2,r5
 20005d0:	28 45 00 00 	lw r5,(r2+0)
  // insert the extracted task on the topo of the stack
  EE_th_next[temp] = EE_stkfirst;
 20005d4:	38 63 0e 94 	ori r3,r3,0xe94
  EE_TID temp;

  temp = EE_rqfirst;
  
  // extract the first task from the ready queue
  EE_rqfirst = EE_th_next[temp]; 
 20005d8:	58 85 00 00 	sw (r4+0),r5
  // insert the extracted task on the topo of the stack
  EE_th_next[temp] = EE_stkfirst;
 20005dc:	28 64 00 00 	lw r4,(r3+0)
  EE_stkfirst = temp;
 20005e0:	58 61 00 00 	sw (r3+0),r1
  temp = EE_rqfirst;
  
  // extract the first task from the ready queue
  EE_rqfirst = EE_th_next[temp]; 
  // insert the extracted task on the topo of the stack
  EE_th_next[temp] = EE_stkfirst;
 20005e4:	58 44 00 00 	sw (r2+0),r4
  EE_stkfirst = temp;

  return temp;
}
 20005e8:	c3 a0 00 00 	ret

020005ec <EE_fp_ActivateTask>:
#include "ee_internal.h"

#ifndef __PRIVATE_ACTIVATETASK__

void EE_fp_ActivateTask(EE_TID t)
{
 20005ec:	37 9c ff ec 	addi sp,sp,-20
 20005f0:	5b 8b 00 14 	sw (sp+20),r11
 20005f4:	5b 8c 00 10 	sw (sp+16),r12
 20005f8:	5b 8d 00 0c 	sw (sp+12),r13
 20005fc:	5b 8e 00 08 	sw (sp+8),r14
 2000600:	5b 9d 00 04 	sw (sp+4),ra
 2000604:	b8 20 20 00 	mv r4,r1
 * Disable interrupts
 */
__INLINE__ EE_FREG __ALWAYS_INLINE__ EE_mico32_disableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 2000608:	90 00 70 00 	rcsr r14,IE
    newie = oldie & (~0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 200060c:	34 01 ff fe 	mvi r1,-2
 2000610:	a1 c1 08 00 	and r1,r14,r1
 2000614:	d0 01 00 00 	wcsr IE,r1
#endif
    
    flag = EE_hal_begin_nested_primitive();
    
    /* check for first activation */
    if (EE_th_nact[t] == 0) {
 2000618:	78 0b 02 00 	mvhi r11,0x200
 200061c:	3c 8c 00 02 	sli r12,r4,2
 2000620:	39 6b 11 60 	ori r11,r11,0x1160
 2000624:	b5 6c 68 00 	add r13,r11,r12
 2000628:	29 a3 00 00 	lw r3,(r13+0)
 200062c:	44 60 00 37 	be r3,r0,2000708 <EE_fp_ActivateTask+0x11c>
#endif
      EE_rq_insert(t);
    }
    
    /* activate the task avoiding the counter wraparound */
    if (EE_th_nact[t] != EE_MAX_NACT)
 2000630:	34 01 ff ff 	mvi r1,-1
 2000634:	44 61 00 04 	be r3,r1,2000644 <EE_fp_ActivateTask+0x58>
      EE_th_nact[t] ++;
 2000638:	b5 6c 10 00 	add r2,r11,r12
 200063c:	34 61 00 01 	addi r1,r3,1
 2000640:	58 41 00 00 	sw (r2+0),r1
    
    /* check for preemption */
    if (!EE_hal_get_IRQ_nesting_level()) {
 2000644:	78 01 02 00 	mvhi r1,0x200
 2000648:	38 21 11 ec 	ori r1,r1,0x11ec
 200064c:	28 22 00 00 	lw r2,(r1+0)
 2000650:	5c 40 00 22 	bne r2,r0,20006d8 <EE_fp_ActivateTask+0xec>
 2000654:	78 01 02 00 	mvhi r1,0x200
 2000658:	38 21 0e 98 	ori r1,r1,0xe98
 200065c:	28 21 00 00 	lw r1,(r1+0)
      tmp = EE_rq_queryfirst();
      if (tmp != EE_NIL) {
 2000660:	34 02 ff ff 	mvi r2,-1
 2000664:	44 22 00 1d 	be r1,r2,20006d8 <EE_fp_ActivateTask+0xec>
	if (EE_sys_ceiling < EE_th_ready_prio[tmp]) {
 2000668:	3c 23 00 02 	sli r3,r1,2
 200066c:	78 01 02 00 	mvhi r1,0x200
 2000670:	38 21 0e 7c 	ori r1,r1,0xe7c
 2000674:	78 05 02 00 	mvhi r5,0x200
 2000678:	38 a5 11 54 	ori r5,r5,0x1154
 200067c:	b4 23 08 00 	add r1,r1,r3
 2000680:	28 22 00 00 	lw r2,(r1+0)
 2000684:	28 a6 00 00 	lw r6,(r5+0)
 2000688:	50 c2 00 14 	bgeu r6,r2,20006d8 <EE_fp_ActivateTask+0xec>
	  
#if defined(__MULTI__) || defined(__WITH_STATUS__)
	  EE_th_status[tmp] = EE_STACKED;
#endif
	  
	  EE_sys_ceiling |= EE_th_dispatch_prio[tmp];
 200068c:	78 01 02 00 	mvhi r1,0x200
 2000690:	38 21 0e 80 	ori r1,r1,0xe80
      if (tmp != EE_NIL) {
	if (EE_sys_ceiling < EE_th_ready_prio[tmp]) {
#if defined(__MULTI__)
	  register int wasstacked;
	  
	  wasstacked = EE_th_status[tmp] & EE_WASSTACKED;
 2000694:	78 02 02 00 	mvhi r2,0x200
	  
#if defined(__MULTI__) || defined(__WITH_STATUS__)
	  EE_th_status[tmp] = EE_STACKED;
#endif
	  
	  EE_sys_ceiling |= EE_th_dispatch_prio[tmp];
 2000698:	b4 23 08 00 	add r1,r1,r3
      if (tmp != EE_NIL) {
	if (EE_sys_ceiling < EE_th_ready_prio[tmp]) {
#if defined(__MULTI__)
	  register int wasstacked;
	  
	  wasstacked = EE_th_status[tmp] & EE_WASSTACKED;
 200069c:	38 42 0e 8c 	ori r2,r2,0xe8c
 20006a0:	b4 43 10 00 	add r2,r2,r3
	  
#if defined(__MULTI__) || defined(__WITH_STATUS__)
	  EE_th_status[tmp] = EE_STACKED;
#endif
	  
	  EE_sys_ceiling |= EE_th_dispatch_prio[tmp];
 20006a4:	28 23 00 00 	lw r3,(r1+0)
      if (tmp != EE_NIL) {
	if (EE_sys_ceiling < EE_th_ready_prio[tmp]) {
#if defined(__MULTI__)
	  register int wasstacked;
	  
	  wasstacked = EE_th_status[tmp] & EE_WASSTACKED;
 20006a8:	28 44 00 00 	lw r4,(r2+0)
#endif
	  
#if defined(__MULTI__) || defined(__WITH_STATUS__)
	  EE_th_status[tmp] = EE_STACKED;
 20006ac:	34 01 00 02 	mvi r1,2
#endif
	  
	  EE_sys_ceiling |= EE_th_dispatch_prio[tmp];
 20006b0:	b8 66 18 00 	or r3,r3,r6
	  
	  wasstacked = EE_th_status[tmp] & EE_WASSTACKED;
#endif
	  
#if defined(__MULTI__) || defined(__WITH_STATUS__)
	  EE_th_status[tmp] = EE_STACKED;
 20006b4:	58 41 00 00 	sw (r2+0),r1
#endif
	  
	  EE_sys_ceiling |= EE_th_dispatch_prio[tmp];
 20006b8:	58 a3 00 00 	sw (r5+0),r3
      if (tmp != EE_NIL) {
	if (EE_sys_ceiling < EE_th_ready_prio[tmp]) {
#if defined(__MULTI__)
	  register int wasstacked;
	  
	  wasstacked = EE_th_status[tmp] & EE_WASSTACKED;
 20006bc:	20 84 00 08 	andi r4,r4,0x8
#endif
	  
	  EE_sys_ceiling |= EE_th_dispatch_prio[tmp];
	  
#if defined(__MULTI__)
	  if (wasstacked)
 20006c0:	44 80 00 1b 	be r4,r0,200072c <EE_fp_ActivateTask+0x140>
	    EE_hal_stkchange(EE_rq2stk_exchange());
 20006c4:	fb ff ff bb 	calli 20005b0 <EE_rq2stk_exchange>
#define EE_std_need_context_change(tid) (((tid) >= 0) || \
(EE_hal_active_tos != EE_std_thread_tos[tid+1]))

__INLINE__ void __ALWAYS_INLINE__ EE_hal_stkchange(EE_TID tid)
{
    EE_std_change_context(EE_std_mark_tid_stacked(tid));
 20006c8:	78 02 80 00 	mvhi r2,0x8000
 20006cc:	38 42 00 00 	ori r2,r2,0x0
 20006d0:	b8 22 08 00 	or r1,r1,r2
 20006d4:	fb ff ff 3e 	calli 20003cc <EE_std_change_context>

/* Called as _last_ function of a primitive that can be called in
   an IRQ and in a task.  Enable IRQs if they were enabled before entering. */
__INLINE__ void __ALWAYS_INLINE__ EE_hal_end_nested_primitive(EE_FREG f)
{
    if (EE_mico32_are_IRQs_enabled(f))
 20006d8:	21 c1 00 01 	andi r1,r14,0x1
 20006dc:	44 20 00 04 	be r1,r0,20006ec <EE_fp_ActivateTask+0x100>
 * Enable interrupts
 */
__INLINE__ void __ALWAYS_INLINE__ EE_mico32_enableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 20006e0:	90 00 08 00 	rcsr r1,IE
    newie = oldie | (0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 20006e4:	38 21 00 01 	ori r1,r1,0x1
 20006e8:	d0 01 00 00 	wcsr IE,r1
    EE_hal_end_nested_primitive(flag);
    
#ifdef __RN_TASK__
  }
#endif
}
 20006ec:	2b 9d 00 04 	lw ra,(sp+4)
 20006f0:	2b 8b 00 14 	lw r11,(sp+20)
 20006f4:	2b 8c 00 10 	lw r12,(sp+16)
 20006f8:	2b 8d 00 0c 	lw r13,(sp+12)
 20006fc:	2b 8e 00 08 	lw r14,(sp+8)
 2000700:	37 9c 00 14 	addi sp,sp,20
 2000704:	c3 a0 00 00 	ret
    flag = EE_hal_begin_nested_primitive();
    
    /* check for first activation */
    if (EE_th_nact[t] == 0) {
#if defined(__MULTI__) || defined(__WITH_STATUS__)
      EE_th_status[t] = EE_READY;
 2000708:	78 02 02 00 	mvhi r2,0x200
 200070c:	38 42 0e 8c 	ori r2,r2,0xe8c
 2000710:	34 03 00 01 	mvi r3,1
 2000714:	b4 4c 10 00 	add r2,r2,r12
 2000718:	58 43 00 00 	sw (r2+0),r3
#endif
      EE_rq_insert(t);
 200071c:	b8 80 08 00 	mv r1,r4
 2000720:	f8 00 01 52 	calli 2000c68 <EE_rq_insert>
 2000724:	29 a3 00 00 	lw r3,(r13+0)
 2000728:	e3 ff ff c2 	bi 2000630 <EE_fp_ActivateTask+0x44>
	  
#if defined(__MULTI__)
	  if (wasstacked)
	    EE_hal_stkchange(EE_rq2stk_exchange());
	  else
	    EE_hal_ready2stacked(EE_rq2stk_exchange());
 200072c:	fb ff ff a1 	calli 20005b0 <EE_rq2stk_exchange>
 * version, all the stack-related stuff is ignored. */


__INLINE__ void EE_hal_ready2stacked(EE_TID tid)
{
    EE_std_change_context(tid);
 2000730:	fb ff ff 27 	calli 20003cc <EE_std_change_context>
 2000734:	e3 ff ff e9 	bi 20006d8 <EE_fp_ActivateTask+0xec>

02000738 <EE_hal_uart_enable_tx_ISR>:
	
	return EE_UART_OK;
}

int EE_hal_uart_enable_tx_ISR(EE_uart_st* usp)
{
 2000738:	28 25 00 08 	lw r5,(r1+8)
	unsigned int intst, mode = usp->mode;;
 200073c:	28 23 00 04 	lw r3,(r1+4)
 * Disable interrupts
 */
__INLINE__ EE_FREG __ALWAYS_INLINE__ EE_mico32_disableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 2000740:	90 00 20 00 	rcsr r4,IE
    newie = oldie & (~0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 2000744:	34 01 ff fe 	mvi r1,-2
 2000748:	a0 81 08 00 	and r1,r4,r1
 200074c:	d0 01 00 00 	wcsr IE,r1
	MicoUart_t *uartc = usp->base; 
	
	intst = EE_mico32_disableIRQ();				
	ee_uart_tip = 1;								// transmission in progress...
 2000750:	78 02 02 00 	mvhi r2,0x200
 2000754:	34 01 00 01 	mvi r1,1
 2000758:	38 42 11 5c 	ori r2,r2,0x115c
 200075c:	58 41 00 00 	sw (r2+0),r1
	if(EE_uart_enabled_rx_int(mode))
 2000760:	a0 61 18 00 	and r3,r3,r1
 2000764:	44 60 00 0a 	be r3,r0,200078c <EE_hal_uart_enable_tx_ISR+0x54>
		uartc->ier = (volatile unsigned int)(MICOUART_IER_RX_INT_MASK | MICOUART_IER_TX_INT_MASK);
 2000768:	34 01 00 03 	mvi r1,3
 200076c:	58 a1 00 04 	sw (r5+4),r1
	else
		uartc->ier = (volatile unsigned int)(MICOUART_IER_TX_INT_MASK);	// Enable interrupts to empty the tx buffer...
	if (EE_mico32_are_IRQs_enabled(intst))		
 2000770:	20 81 00 01 	andi r1,r4,0x1
 2000774:	44 20 00 04 	be r1,r0,2000784 <EE_hal_uart_enable_tx_ISR+0x4c>
 * Enable interrupts
 */
__INLINE__ void __ALWAYS_INLINE__ EE_mico32_enableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 2000778:	90 00 08 00 	rcsr r1,IE
    newie = oldie | (0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 200077c:	38 21 00 01 	ori r1,r1,0x1
 2000780:	d0 01 00 00 	wcsr IE,r1
	   	EE_mico32_enableIRQ();
	   	
	return EE_UART_OK;	
}
 2000784:	34 01 00 00 	mvi r1,0
 2000788:	c3 a0 00 00 	ret
	intst = EE_mico32_disableIRQ();				
	ee_uart_tip = 1;								// transmission in progress...
	if(EE_uart_enabled_rx_int(mode))
		uartc->ier = (volatile unsigned int)(MICOUART_IER_RX_INT_MASK | MICOUART_IER_TX_INT_MASK);
	else
		uartc->ier = (volatile unsigned int)(MICOUART_IER_TX_INT_MASK);	// Enable interrupts to empty the tx buffer...
 200078c:	34 01 00 02 	mvi r1,2
 2000790:	58 a1 00 04 	sw (r5+4),r1
 2000794:	e3 ff ff f7 	bi 2000770 <EE_hal_uart_enable_tx_ISR+0x38>

02000798 <EE_hal_uart_write_buffer>:
	- isr mode:
		- blocking mode: wait if a transmission is in progress or if buffer is full, return the number of bytes loaded (should be loaded all characters...)
		- no-blocking mode: no wait if buffer is full or if a transmission is in progress, return the number of bytes loaded
*/
int EE_hal_uart_write_buffer(EE_uart_st* usp, EE_UINT8 *vet, int len)
{
 2000798:	37 9c ff dc 	addi sp,sp,-36
 200079c:	5b 8b 00 24 	sw (sp+36),r11
 20007a0:	5b 8c 00 20 	sw (sp+32),r12
 20007a4:	5b 8d 00 1c 	sw (sp+28),r13
 20007a8:	5b 8e 00 18 	sw (sp+24),r14
 20007ac:	5b 8f 00 14 	sw (sp+20),r15
 20007b0:	5b 90 00 10 	sw (sp+16),r16
 20007b4:	5b 91 00 0c 	sw (sp+12),r17
 20007b8:	5b 92 00 08 	sw (sp+8),r18
 20007bc:	5b 9d 00 04 	sw (sp+4),ra
	int ret,i;
  
	MicoUart_t *uartc = usp->base; 
	
	buffer = &usp->txbuf;
	mode = usp->mode;
 20007c0:	28 25 00 04 	lw r5,(r1+4)
	- isr mode:
		- blocking mode: wait if a transmission is in progress or if buffer is full, return the number of bytes loaded (should be loaded all characters...)
		- no-blocking mode: no wait if buffer is full or if a transmission is in progress, return the number of bytes loaded
*/
int EE_hal_uart_write_buffer(EE_uart_st* usp, EE_UINT8 *vet, int len)
{
 20007c4:	b8 20 60 00 	mv r12,r1
 20007c8:	b8 40 78 00 	mv r15,r2
	MicoUart_t *uartc = usp->base; 
	
	buffer = &usp->txbuf;
	mode = usp->mode;
	
	if( EE_uart_tx_polling(mode) )							// TX POLLING MODE
 20007cc:	20 a1 00 02 	andi r1,r5,0x2
	- isr mode:
		- blocking mode: wait if a transmission is in progress or if buffer is full, return the number of bytes loaded (should be loaded all characters...)
		- no-blocking mode: no wait if buffer is full or if a transmission is in progress, return the number of bytes loaded
*/
int EE_hal_uart_write_buffer(EE_uart_st* usp, EE_UINT8 *vet, int len)
{
 20007d0:	b8 60 70 00 	mv r14,r3
	unsigned int uiValue, mode;
	EE_buffer* buffer;
	int ret,i;
  
	MicoUart_t *uartc = usp->base; 
 20007d4:	29 84 00 08 	lw r4,(r12+8)
	
	buffer = &usp->txbuf;
 20007d8:	35 90 00 30 	addi r16,r12,48
	mode = usp->mode;
	
	if( EE_uart_tx_polling(mode) )							// TX POLLING MODE
 20007dc:	44 20 00 0f 	be r1,r0,2000818 <EE_hal_uart_write_buffer+0x80>
		}
		ret = len;											// all bytes transmitted... 
	}
	else
	{	// if there is no transmission in progress or there is a transmission in progress but we are in blocking mode
		if( !ee_uart_tip || (ee_uart_tip && EE_uart_tx_block(mode)) )
 20007e0:	78 0d 02 00 	mvhi r13,0x200
 20007e4:	39 ad 11 5c 	ori r13,r13,0x115c
 20007e8:	29 a1 00 00 	lw r1,(r13+0)
 20007ec:	5c 20 00 35 	bne r1,r0,20008c0 <EE_hal_uart_write_buffer+0x128>
		{																																			
			while(ee_uart_tip)
 20007f0:	29 a1 00 00 	lw r1,(r13+0)
 20007f4:	5c 20 ff ff 	bne r1,r0,20007f0 <EE_hal_uart_write_buffer+0x58>
				;								// wait until transmission is finished...
			for(i=0; i<len; i++)
 20007f8:	b8 20 58 00 	mv r11,r1
				if(ret == EE_BUF_OK)						// byte loaded in the tx buffer... 
					usp->err = ret; 
				else
				{
					usp->err = EE_UART_ERR_TX_BUF_FULL;
					if(!EE_uart_tx_block(mode))
 20007fc:	20 b1 00 20 	andi r17,r5,0x20
				ret = EE_buffer_putmsg(buffer, vet+i);
				if(ret == EE_BUF_OK)						// byte loaded in the tx buffer... 
					usp->err = ret; 
				else
				{
					usp->err = EE_UART_ERR_TX_BUF_FULL;
 2000800:	34 12 ff f9 	mvi r18,-7
	{	// if there is no transmission in progress or there is a transmission in progress but we are in blocking mode
		if( !ee_uart_tip || (ee_uart_tip && EE_uart_tx_block(mode)) )
		{																																			
			while(ee_uart_tip)
				;								// wait until transmission is finished...
			for(i=0; i<len; i++)
 2000804:	49 c1 00 24 	bg r14,r1,2000894 <EE_hal_uart_write_buffer+0xfc>
						while(ee_uart_tip)
							;								// wait until transmission is finished...
					}
				}
			}
			EE_hal_uart_enable_tx_ISR(usp);					// enable tx interrupt
 2000808:	b9 80 08 00 	mv r1,r12
 200080c:	fb ff ff cb 	calli 2000738 <EE_hal_uart_enable_tx_ISR>
 2000810:	b9 60 08 00 	mv r1,r11
 2000814:	e0 00 00 0d 	bi 2000848 <EE_hal_uart_write_buffer+0xb0>
	buffer = &usp->txbuf;
	mode = usp->mode;
	
	if( EE_uart_tx_polling(mode) )							// TX POLLING MODE
	{							
		for(i=0; i<len; i++)
 2000818:	4c 23 00 1d 	bge r1,r3,200088c <EE_hal_uart_write_buffer+0xf4>
 200081c:	b8 20 18 00 	mv r3,r1
    				break;
				}
				else if(i==0)
				{											// if TX is not ready because another task uses tx buffer...
					usp->err = EE_UART_ERR_TX_NOT_READY;
					if(!EE_uart_tx_block(mode))				// no bytes transmitted, operation failed...
 2000820:	20 a5 00 20 	andi r5,r5,0x20
		{
			do
			{
				/* if uart's ready to accept character, send immediately */
    			uiValue = uartc->lsr;
    			if(uiValue & MICOUART_LSR_TX_RDY_MASK)
 2000824:	b8 20 38 00 	mv r7,r1
    				usp->err = EE_UART_OK;
    				break;
				}
				else if(i==0)
				{											// if TX is not ready because another task uses tx buffer...
					usp->err = EE_UART_ERR_TX_NOT_READY;
 2000828:	34 06 ff f6 	mvi r6,-10
		for(i=0; i<len; i++)
		{
			do
			{
				/* if uart's ready to accept character, send immediately */
    			uiValue = uartc->lsr;
 200082c:	28 81 00 14 	lw r1,(r4+20)
    			if(uiValue & MICOUART_LSR_TX_RDY_MASK)
 2000830:	20 21 00 20 	andi r1,r1,0x20
 2000834:	5c 20 00 10 	bne r1,r0,2000874 <EE_hal_uart_write_buffer+0xdc>
    				uartc->rxtx = vet[i];					// byte loaded in the uart tx buffer
    				ret = 1;
    				usp->err = EE_UART_OK;
    				break;
				}
				else if(i==0)
 2000838:	5c 61 ff fd 	bne r3,r1,200082c <EE_hal_uart_write_buffer+0x94>
				{											// if TX is not ready because another task uses tx buffer...
					usp->err = EE_UART_ERR_TX_NOT_READY;
 200083c:	59 86 00 00 	sw (r12+0),r6
					if(!EE_uart_tx_block(mode))				// no bytes transmitted, operation failed...
 2000840:	5c a3 ff fb 	bne r5,r3,200082c <EE_hal_uart_write_buffer+0x94>
 2000844:	b8 c0 08 00 	mv r1,r6
		}
	}
	
	// All done!!!
	return ret;
}
 2000848:	2b 9d 00 04 	lw ra,(sp+4)
 200084c:	2b 8b 00 24 	lw r11,(sp+36)
 2000850:	2b 8c 00 20 	lw r12,(sp+32)
 2000854:	2b 8d 00 1c 	lw r13,(sp+28)
 2000858:	2b 8e 00 18 	lw r14,(sp+24)
 200085c:	2b 8f 00 14 	lw r15,(sp+20)
 2000860:	2b 90 00 10 	lw r16,(sp+16)
 2000864:	2b 91 00 0c 	lw r17,(sp+12)
 2000868:	2b 92 00 08 	lw r18,(sp+8)
 200086c:	37 9c 00 24 	addi sp,sp,36
 2000870:	c3 a0 00 00 	ret
			{
				/* if uart's ready to accept character, send immediately */
    			uiValue = uartc->lsr;
    			if(uiValue & MICOUART_LSR_TX_RDY_MASK)
				{
    				uartc->rxtx = vet[i];					// byte loaded in the uart tx buffer
 2000874:	b5 e3 08 00 	add r1,r15,r3
 2000878:	40 22 00 00 	lbu r2,(r1+0)
	buffer = &usp->txbuf;
	mode = usp->mode;
	
	if( EE_uart_tx_polling(mode) )							// TX POLLING MODE
	{							
		for(i=0; i<len; i++)
 200087c:	34 63 00 01 	addi r3,r3,1
			{
				/* if uart's ready to accept character, send immediately */
    			uiValue = uartc->lsr;
    			if(uiValue & MICOUART_LSR_TX_RDY_MASK)
				{
    				uartc->rxtx = vet[i];					// byte loaded in the uart tx buffer
 2000880:	58 82 00 00 	sw (r4+0),r2
    				ret = 1;
    				usp->err = EE_UART_OK;
 2000884:	59 87 00 00 	sw (r12+0),r7
	buffer = &usp->txbuf;
	mode = usp->mode;
	
	if( EE_uart_tx_polling(mode) )							// TX POLLING MODE
	{							
		for(i=0; i<len; i++)
 2000888:	49 c3 ff e9 	bg r14,r3,200082c <EE_hal_uart_write_buffer+0x94>
			EE_hal_uart_enable_tx_ISR(usp);					// enable tx interrupt
	        ret = i;										// number of bytes loaded in the tx buffer
		}
		else												// there is a transmission in progress and we are in non blocking mode
		{
			usp->err = EE_UART_ERR_TX_NOT_READY;
 200088c:	b9 c0 08 00 	mv r1,r14
 2000890:	e3 ff ff ee 	bi 2000848 <EE_hal_uart_write_buffer+0xb0>
		{																																			
			while(ee_uart_tip)
				;								// wait until transmission is finished...
			for(i=0; i<len; i++)
			{
				ret = EE_buffer_putmsg(buffer, vet+i);
 2000894:	ba 00 08 00 	mv r1,r16
 2000898:	b5 eb 10 00 	add r2,r15,r11
 200089c:	f8 00 00 7a 	calli 2000a84 <EE_buffer_putmsg>
				if(ret == EE_BUF_OK)						// byte loaded in the tx buffer... 
 20008a0:	5c 20 00 0d 	bne r1,r0,20008d4 <EE_hal_uart_write_buffer+0x13c>
					usp->err = ret; 
 20008a4:	59 81 00 00 	sw (r12+0),r1
	{	// if there is no transmission in progress or there is a transmission in progress but we are in blocking mode
		if( !ee_uart_tip || (ee_uart_tip && EE_uart_tx_block(mode)) )
		{																																			
			while(ee_uart_tip)
				;								// wait until transmission is finished...
			for(i=0; i<len; i++)
 20008a8:	35 6b 00 01 	addi r11,r11,1
 20008ac:	49 cb ff fa 	bg r14,r11,2000894 <EE_hal_uart_write_buffer+0xfc>
						while(ee_uart_tip)
							;								// wait until transmission is finished...
					}
				}
			}
			EE_hal_uart_enable_tx_ISR(usp);					// enable tx interrupt
 20008b0:	b9 80 08 00 	mv r1,r12
 20008b4:	fb ff ff a1 	calli 2000738 <EE_hal_uart_enable_tx_ISR>
 20008b8:	b9 60 08 00 	mv r1,r11
 20008bc:	e3 ff ff e3 	bi 2000848 <EE_hal_uart_write_buffer+0xb0>
		}
		ret = len;											// all bytes transmitted... 
	}
	else
	{	// if there is no transmission in progress or there is a transmission in progress but we are in blocking mode
		if( !ee_uart_tip || (ee_uart_tip && EE_uart_tx_block(mode)) )
 20008c0:	29 a1 00 00 	lw r1,(r13+0)
 20008c4:	5c 20 00 0c 	bne r1,r0,20008f4 <EE_hal_uart_write_buffer+0x15c>
			EE_hal_uart_enable_tx_ISR(usp);					// enable tx interrupt
	        ret = i;										// number of bytes loaded in the tx buffer
		}
		else												// there is a transmission in progress and we are in non blocking mode
		{
			usp->err = EE_UART_ERR_TX_NOT_READY;
 20008c8:	34 01 ff f6 	mvi r1,-10
 20008cc:	59 81 00 00 	sw (r12+0),r1
 20008d0:	e3 ff ff de 	bi 2000848 <EE_hal_uart_write_buffer+0xb0>
				ret = EE_buffer_putmsg(buffer, vet+i);
				if(ret == EE_BUF_OK)						// byte loaded in the tx buffer... 
					usp->err = ret; 
				else
				{
					usp->err = EE_UART_ERR_TX_BUF_FULL;
 20008d4:	59 92 00 00 	sw (r12+0),r18
					if(!EE_uart_tx_block(mode))
 20008d8:	46 20 ff cc 	be r17,r0,2000808 <EE_hal_uart_write_buffer+0x70>
						break;
					else
					{
						i--;											// restore the previous character...
						EE_hal_uart_enable_tx_ISR(usp);					// enable tx interrupt
 20008dc:	b9 80 08 00 	mv r1,r12
 20008e0:	fb ff ff 96 	calli 2000738 <EE_hal_uart_enable_tx_ISR>
						while(ee_uart_tip)
 20008e4:	29 a1 00 00 	lw r1,(r13+0)
 20008e8:	5c 20 ff ff 	bne r1,r0,20008e4 <EE_hal_uart_write_buffer+0x14c>
					usp->err = EE_UART_ERR_TX_BUF_FULL;
					if(!EE_uart_tx_block(mode))
						break;
					else
					{
						i--;											// restore the previous character...
 20008ec:	35 6b ff ff 	addi r11,r11,-1
 20008f0:	e3 ff ff ee 	bi 20008a8 <EE_hal_uart_write_buffer+0x110>
		}
		ret = len;											// all bytes transmitted... 
	}
	else
	{	// if there is no transmission in progress or there is a transmission in progress but we are in blocking mode
		if( !ee_uart_tip || (ee_uart_tip && EE_uart_tx_block(mode)) )
 20008f4:	20 a1 00 20 	andi r1,r5,0x20
 20008f8:	44 20 ff f4 	be r1,r0,20008c8 <EE_hal_uart_write_buffer+0x130>
 20008fc:	e3 ff ff bd 	bi 20007f0 <EE_hal_uart_write_buffer+0x58>

02000900 <EE_hal_uart_read_byte>:
	- isr mode:
		- blocking mode: wait until rx buffer is ready, return 1
		- no-blocking mode: no wait, return EE_UART_ERR_RX_BUF_EMPTY
*/
int EE_hal_uart_read_byte(EE_uart_st* usp, EE_UINT8 *data)
{
 2000900:	37 9c ff e8 	addi sp,sp,-24
 2000904:	5b 8b 00 18 	sw (sp+24),r11
 2000908:	5b 8c 00 14 	sw (sp+20),r12
 200090c:	5b 8d 00 10 	sw (sp+16),r13
 2000910:	5b 8e 00 0c 	sw (sp+12),r14
 2000914:	5b 8f 00 08 	sw (sp+8),r15
 2000918:	5b 9d 00 04 	sw (sp+4),ra
	EE_buffer* buffer;
	
	MicoUart_t *uartc = usp->base; 

	buffer = &usp->rxbuf;
	mode = usp->mode;
 200091c:	28 23 00 04 	lw r3,(r1+4)
	- isr mode:
		- blocking mode: wait until rx buffer is ready, return 1
		- no-blocking mode: no wait, return EE_UART_ERR_RX_BUF_EMPTY
*/
int EE_hal_uart_read_byte(EE_uart_st* usp, EE_UINT8 *data)
{
 2000920:	b8 20 58 00 	mv r11,r1
 2000924:	b8 40 78 00 	mv r15,r2
	unsigned int uiValue; 
	int mode;
	int ret;
	EE_buffer* buffer;
	
	MicoUart_t *uartc = usp->base; 
 2000928:	28 22 00 08 	lw r2,(r1+8)

	buffer = &usp->rxbuf;
	mode = usp->mode;
	
	if( EE_uart_rx_polling(mode) )								// RX POLLING MODE
 200092c:	20 61 00 01 	andi r1,r3,0x1
	int ret;
	EE_buffer* buffer;
	
	MicoUart_t *uartc = usp->base; 

	buffer = &usp->rxbuf;
 2000930:	35 6d 00 18 	addi r13,r11,24
				usp->err = ret;
				break;
			}
			else
			{	
				usp->err = EE_UART_ERR_RX_BUF_EMPTY;
 2000934:	34 0e ff fa 	mvi r14,-6
				if(!EE_uart_rx_block(mode))
 2000938:	20 6c 00 10 	andi r12,r3,0x10
	MicoUart_t *uartc = usp->base; 

	buffer = &usp->rxbuf;
	mode = usp->mode;
	
	if( EE_uart_rx_polling(mode) )								// RX POLLING MODE
 200093c:	5c 20 00 10 	bne r1,r0,200097c <EE_hal_uart_read_byte+0x7c>
        		// All done!!!
    			break;
    		}
			else
			{
    			if(!EE_uart_rx_block(mode))						// if no blocking mode
 2000940:	b9 80 18 00 	mv r3,r12
	
	if( EE_uart_rx_polling(mode) )								// RX POLLING MODE
	{					
		do
		{
			uiValue = uartc->lsr;
 2000944:	28 41 00 14 	lw r1,(r2+20)
			if(uiValue & MICOUART_LSR_RX_RDY_MASK)
 2000948:	20 21 00 01 	andi r1,r1,0x1
 200094c:	5c 20 00 25 	bne r1,r0,20009e0 <EE_hal_uart_read_byte+0xe0>
        		// All done!!!
    			break;
    		}
			else
			{
    			if(!EE_uart_rx_block(mode))						// if no blocking mode
 2000950:	5c 61 ff fd 	bne r3,r1,2000944 <EE_hal_uart_read_byte+0x44>
				{					
	    			usp->err = EE_UART_ERR_RX_NOT_READY;
 2000954:	34 01 ff f5 	mvi r1,-11
 2000958:	59 61 00 00 	sw (r11+0),r1
	}

		
    // All done!!!
	return ret;
}
 200095c:	2b 9d 00 04 	lw ra,(sp+4)
 2000960:	2b 8b 00 18 	lw r11,(sp+24)
 2000964:	2b 8c 00 14 	lw r12,(sp+20)
 2000968:	2b 8d 00 10 	lw r13,(sp+16)
 200096c:	2b 8e 00 0c 	lw r14,(sp+12)
 2000970:	2b 8f 00 08 	lw r15,(sp+8)
 2000974:	37 9c 00 18 	addi sp,sp,24
 2000978:	c3 a0 00 00 	ret
	}
	else
	{
		do
		{
			ret = EE_buffer_getmsg(buffer, data);			
 200097c:	b9 a0 08 00 	mv r1,r13
 2000980:	b9 e0 10 00 	mv r2,r15
 2000984:	f8 00 00 72 	calli 2000b4c <EE_buffer_getmsg>
			if(ret == EE_BUF_OK)								// byte extracted from the rx buffer
 2000988:	44 20 00 0c 	be r1,r0,20009b8 <EE_hal_uart_read_byte+0xb8>
				usp->err = ret;
				break;
			}
			else
			{	
				usp->err = EE_UART_ERR_RX_BUF_EMPTY;
 200098c:	59 6e 00 00 	sw (r11+0),r14
				if(!EE_uart_rx_block(mode))
 2000990:	5d 80 ff fb 	bne r12,r0,200097c <EE_hal_uart_read_byte+0x7c>
 2000994:	b9 c0 08 00 	mv r1,r14
	}

		
    // All done!!!
	return ret;
}
 2000998:	2b 9d 00 04 	lw ra,(sp+4)
 200099c:	2b 8b 00 18 	lw r11,(sp+24)
 20009a0:	2b 8c 00 14 	lw r12,(sp+20)
 20009a4:	2b 8d 00 10 	lw r13,(sp+16)
 20009a8:	2b 8e 00 0c 	lw r14,(sp+12)
 20009ac:	2b 8f 00 08 	lw r15,(sp+8)
 20009b0:	37 9c 00 18 	addi sp,sp,24
 20009b4:	c3 a0 00 00 	ret
		{
			ret = EE_buffer_getmsg(buffer, data);			
			if(ret == EE_BUF_OK)								// byte extracted from the rx buffer
			{								
				ret = 1;
				usp->err = ret;
 20009b8:	34 01 00 01 	mvi r1,1
 20009bc:	59 61 00 00 	sw (r11+0),r1
	}

		
    // All done!!!
	return ret;
}
 20009c0:	2b 9d 00 04 	lw ra,(sp+4)
 20009c4:	2b 8b 00 18 	lw r11,(sp+24)
 20009c8:	2b 8c 00 14 	lw r12,(sp+20)
 20009cc:	2b 8d 00 10 	lw r13,(sp+16)
 20009d0:	2b 8e 00 0c 	lw r14,(sp+12)
 20009d4:	2b 8f 00 08 	lw r15,(sp+8)
 20009d8:	37 9c 00 18 	addi sp,sp,24
 20009dc:	c3 a0 00 00 	ret
		{
			uiValue = uartc->lsr;
			if(uiValue & MICOUART_LSR_RX_RDY_MASK)
			{
				ret = 1;										// one byte received.
    			usp->err = EE_UART_OK;
 20009e0:	34 01 00 00 	mvi r1,0
 20009e4:	59 61 00 00 	sw (r11+0),r1
    			*data = uartc->rxtx;
 20009e8:	28 42 00 00 	lw r2,(r2+0)
 20009ec:	34 01 00 01 	mvi r1,1
 20009f0:	31 e2 00 00 	sb (r15+0),r2
	}

		
    // All done!!!
	return ret;
}
 20009f4:	2b 9d 00 04 	lw ra,(sp+4)
 20009f8:	2b 8b 00 18 	lw r11,(sp+24)
 20009fc:	2b 8c 00 14 	lw r12,(sp+20)
 2000a00:	2b 8d 00 10 	lw r13,(sp+16)
 2000a04:	2b 8e 00 0c 	lw r14,(sp+12)
 2000a08:	2b 8f 00 08 	lw r15,(sp+8)
 2000a0c:	37 9c 00 18 	addi sp,sp,24
 2000a10:	c3 a0 00 00 	ret

02000a14 <EE_hal_uart_read_buffer>:
	- isr mode:
		- blocking mode: every time wait until rx buffer is ready (not empty), return the number of the received bytes (should be received all characters...)
		- no-blocking mode: no wait if rx buffer is empty, return the number of the received bytes
*/
int EE_hal_uart_read_buffer(EE_uart_st* usp, EE_UINT8 *vet, int len)
{
 2000a14:	37 9c ff ec 	addi sp,sp,-20
 2000a18:	5b 8b 00 14 	sw (sp+20),r11
 2000a1c:	5b 8c 00 10 	sw (sp+16),r12
 2000a20:	5b 8d 00 0c 	sw (sp+12),r13
 2000a24:	5b 8e 00 08 	sw (sp+8),r14
 2000a28:	5b 9d 00 04 	sw (sp+4),ra
 2000a2c:	b8 20 68 00 	mv r13,r1
 2000a30:	b8 60 70 00 	mv r14,r3
 2000a34:	b8 40 60 00 	mv r12,r2
	int i;
	int ret = EE_UART_ERR_RX_BUF_EMPTY;

	for(i=0; i<len; i++)
 2000a38:	34 01 ff fa 	mvi r1,-6
 2000a3c:	4c 03 00 08 	bge r0,r3,2000a5c <EE_hal_uart_read_buffer+0x48>
 2000a40:	34 0b 00 00 	mvi r11,0
	{
		ret = EE_hal_uart_read_byte(usp, &vet[i]); 
 2000a44:	b5 8b 10 00 	add r2,r12,r11
 2000a48:	b9 a0 08 00 	mv r1,r13
 2000a4c:	fb ff ff ad 	calli 2000900 <EE_hal_uart_read_byte>
		if( ret < 0)
 2000a50:	4c 20 00 0a 	bge r1,r0,2000a78 <EE_hal_uart_read_buffer+0x64>
			break;
	}
	
	if(i==0)
 2000a54:	45 60 00 02 	be r11,r0,2000a5c <EE_hal_uart_read_buffer+0x48>
int EE_hal_uart_read_buffer(EE_uart_st* usp, EE_UINT8 *vet, int len)
{
	int i;
	int ret = EE_UART_ERR_RX_BUF_EMPTY;

	for(i=0; i<len; i++)
 2000a58:	b9 60 08 00 	mv r1,r11
	
	if(i==0)
		return ret;
	else
		return i;	// number of bytes read.
}
 2000a5c:	2b 9d 00 04 	lw ra,(sp+4)
 2000a60:	2b 8b 00 14 	lw r11,(sp+20)
 2000a64:	2b 8c 00 10 	lw r12,(sp+16)
 2000a68:	2b 8d 00 0c 	lw r13,(sp+12)
 2000a6c:	2b 8e 00 08 	lw r14,(sp+8)
 2000a70:	37 9c 00 14 	addi sp,sp,20
 2000a74:	c3 a0 00 00 	ret
int EE_hal_uart_read_buffer(EE_uart_st* usp, EE_UINT8 *vet, int len)
{
	int i;
	int ret = EE_UART_ERR_RX_BUF_EMPTY;

	for(i=0; i<len; i++)
 2000a78:	35 6b 00 01 	addi r11,r11,1
 2000a7c:	49 cb ff f2 	bg r14,r11,2000a44 <EE_hal_uart_read_buffer+0x30>
 2000a80:	e3 ff ff f6 	bi 2000a58 <EE_hal_uart_read_buffer+0x44>

02000a84 <EE_buffer_putmsg>:
		
	return retvalue;	
}

int EE_buffer_putmsg(EE_buffer *buf, EE_UINT8* msg)
{
 2000a84:	b8 40 30 00 	mv r6,r2
 2000a88:	b8 20 28 00 	mv r5,r1
	int retvalue;
	int i=0;
	unsigned int intst;
	
	if(msg==NULL)
 2000a8c:	34 04 ff fc 	mvi r4,-4
 2000a90:	44 40 00 25 	be r2,r0,2000b24 <EE_buffer_putmsg+0xa0>
 * Disable interrupts
 */
__INLINE__ EE_FREG __ALWAYS_INLINE__ EE_mico32_disableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 2000a94:	90 00 38 00 	rcsr r7,IE
    newie = oldie & (~0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 2000a98:	34 01 ff fe 	mvi r1,-2
 2000a9c:	a0 e1 08 00 	and r1,r7,r1
 2000aa0:	d0 01 00 00 	wcsr IE,r1
		return EE_BUF_ERR_NULL;
	
	intst = EE_mico32_disableIRQ();				//EE_hal_disableIRQ();
	if((buf->g == buf->p) && (buf->counter==buf->buf_size))
 2000aa4:	28 a3 00 04 	lw r3,(r5+4)
 2000aa8:	28 a1 00 00 	lw r1,(r5+0)
 2000aac:	44 23 00 20 	be r1,r3,2000b2c <EE_buffer_putmsg+0xa8>
		retvalue = EE_BUF_ERR_FULL;
	else
	{ 	
		for(i=0;i<(buf->msg_size);i++)	
 2000ab0:	28 a2 00 0c 	lw r2,(r5+12)
 2000ab4:	4c 02 00 0f 	bge r0,r2,2000af0 <EE_buffer_putmsg+0x6c>
 2000ab8:	34 04 00 00 	mvi r4,0
    		buf(buf->p,i) = msg[i];				//buf->data[buf->p][i] = msg[i];
 2000abc:	28 a1 00 14 	lw r1,(r5+20)
 2000ac0:	88 43 10 00 	mul r2,r2,r3
 2000ac4:	b4 c4 18 00 	add r3,r6,r4
 2000ac8:	40 63 00 00 	lbu r3,(r3+0)
 2000acc:	b4 24 08 00 	add r1,r1,r4
 2000ad0:	b4 22 08 00 	add r1,r1,r2
 2000ad4:	30 23 00 00 	sb (r1+0),r3
	intst = EE_mico32_disableIRQ();				//EE_hal_disableIRQ();
	if((buf->g == buf->p) && (buf->counter==buf->buf_size))
		retvalue = EE_BUF_ERR_FULL;
	else
	{ 	
		for(i=0;i<(buf->msg_size);i++)	
 2000ad8:	28 a2 00 0c 	lw r2,(r5+12)
 2000adc:	34 84 00 01 	addi r4,r4,1
 2000ae0:	4c 82 00 03 	bge r4,r2,2000aec <EE_buffer_putmsg+0x68>
 2000ae4:	28 a3 00 04 	lw r3,(r5+4)
 2000ae8:	e3 ff ff f5 	bi 2000abc <EE_buffer_putmsg+0x38>
 2000aec:	28 a3 00 04 	lw r3,(r5+4)
    		buf(buf->p,i) = msg[i];				//buf->data[buf->p][i] = msg[i];
    	buf->p++;
    	if(buf->p == buf->buf_size)
 2000af0:	28 a2 00 10 	lw r2,(r5+16)
		retvalue = EE_BUF_ERR_FULL;
	else
	{ 	
		for(i=0;i<(buf->msg_size);i++)	
    		buf(buf->p,i) = msg[i];				//buf->data[buf->p][i] = msg[i];
    	buf->p++;
 2000af4:	34 61 00 01 	addi r1,r3,1
 2000af8:	58 a1 00 04 	sw (r5+4),r1
    	if(buf->p == buf->buf_size)
 2000afc:	44 22 00 11 	be r1,r2,2000b40 <EE_buffer_putmsg+0xbc>
    		buf->p = 0;							//buf->p = (buf->p % (buf->buf_size));
    	buf->counter++;
 2000b00:	28 a1 00 08 	lw r1,(r5+8)
 2000b04:	34 04 00 00 	mvi r4,0
 2000b08:	34 21 00 01 	addi r1,r1,1
 2000b0c:	58 a1 00 08 	sw (r5+8),r1
    	retvalue = EE_BUF_OK;
	}
    if (EE_mico32_are_IRQs_enabled(intst))		//EE_hal_enableIRQ();
 2000b10:	20 e1 00 01 	andi r1,r7,0x1
 2000b14:	44 20 00 04 	be r1,r0,2000b24 <EE_buffer_putmsg+0xa0>
 * Enable interrupts
 */
__INLINE__ void __ALWAYS_INLINE__ EE_mico32_enableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 2000b18:	90 00 08 00 	rcsr r1,IE
    newie = oldie | (0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 2000b1c:	38 21 00 01 	ori r1,r1,0x1
 2000b20:	d0 01 00 00 	wcsr IE,r1
        EE_mico32_enableIRQ();
    
  	return retvalue;
}
 2000b24:	b8 80 08 00 	mv r1,r4
 2000b28:	c3 a0 00 00 	ret
	
	if(msg==NULL)
		return EE_BUF_ERR_NULL;
	
	intst = EE_mico32_disableIRQ();				//EE_hal_disableIRQ();
	if((buf->g == buf->p) && (buf->counter==buf->buf_size))
 2000b2c:	28 a2 00 08 	lw r2,(r5+8)
 2000b30:	28 a1 00 10 	lw r1,(r5+16)
 2000b34:	34 04 ff fe 	mvi r4,-2
 2000b38:	5c 41 ff de 	bne r2,r1,2000ab0 <EE_buffer_putmsg+0x2c>
 2000b3c:	e3 ff ff f5 	bi 2000b10 <EE_buffer_putmsg+0x8c>
	{ 	
		for(i=0;i<(buf->msg_size);i++)	
    		buf(buf->p,i) = msg[i];				//buf->data[buf->p][i] = msg[i];
    	buf->p++;
    	if(buf->p == buf->buf_size)
    		buf->p = 0;							//buf->p = (buf->p % (buf->buf_size));
 2000b40:	34 01 00 00 	mvi r1,0
 2000b44:	58 a1 00 04 	sw (r5+4),r1
 2000b48:	e3 ff ff ee 	bi 2000b00 <EE_buffer_putmsg+0x7c>

02000b4c <EE_buffer_getmsg>:
    
  	return retvalue;
}

int EE_buffer_getmsg(EE_buffer *buf, EE_UINT8* msg)
{
 2000b4c:	b8 40 30 00 	mv r6,r2
 2000b50:	b8 20 28 00 	mv r5,r1
	int retvalue;
	int i=0;
	unsigned int intst;
	
	if(msg==NULL)
 2000b54:	34 02 ff fc 	mvi r2,-4
 2000b58:	44 c0 00 25 	be r6,r0,2000bec <EE_buffer_getmsg+0xa0>
 * Disable interrupts
 */
__INLINE__ EE_FREG __ALWAYS_INLINE__ EE_mico32_disableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 2000b5c:	90 00 38 00 	rcsr r7,IE
    newie = oldie & (~0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 2000b60:	34 01 ff fe 	mvi r1,-2
 2000b64:	a0 e1 08 00 	and r1,r7,r1
 2000b68:	d0 01 00 00 	wcsr IE,r1
		return EE_BUF_ERR_NULL;
	
	intst = EE_mico32_disableIRQ();				//EE_hal_disableIRQ();
	if((buf->g == buf->p) && (buf->counter==0)) 
 2000b6c:	28 a3 00 00 	lw r3,(r5+0)
 2000b70:	28 a1 00 04 	lw r1,(r5+4)
 2000b74:	44 61 00 20 	be r3,r1,2000bf4 <EE_buffer_getmsg+0xa8>
		retvalue = EE_BUF_ERR_EMPTY; 
	else
	{	
  		for(i=0;i<(buf->msg_size);i++)	
 2000b78:	28 a2 00 0c 	lw r2,(r5+12)
 2000b7c:	4c 02 00 0f 	bge r0,r2,2000bb8 <EE_buffer_getmsg+0x6c>
 2000b80:	34 04 00 00 	mvi r4,0
    		msg[i] = buf(buf->g,i);				//buf->data[buf->g][i];
 2000b84:	28 a1 00 14 	lw r1,(r5+20)
 2000b88:	88 62 10 00 	mul r2,r3,r2
 2000b8c:	b4 c4 18 00 	add r3,r6,r4
 2000b90:	b4 24 08 00 	add r1,r1,r4
 2000b94:	b4 22 08 00 	add r1,r1,r2
 2000b98:	40 21 00 00 	lbu r1,(r1+0)
	intst = EE_mico32_disableIRQ();				//EE_hal_disableIRQ();
	if((buf->g == buf->p) && (buf->counter==0)) 
		retvalue = EE_BUF_ERR_EMPTY; 
	else
	{	
  		for(i=0;i<(buf->msg_size);i++)	
 2000b9c:	34 84 00 01 	addi r4,r4,1
    		msg[i] = buf(buf->g,i);				//buf->data[buf->g][i];
 2000ba0:	30 61 00 00 	sb (r3+0),r1
	intst = EE_mico32_disableIRQ();				//EE_hal_disableIRQ();
	if((buf->g == buf->p) && (buf->counter==0)) 
		retvalue = EE_BUF_ERR_EMPTY; 
	else
	{	
  		for(i=0;i<(buf->msg_size);i++)	
 2000ba4:	28 a2 00 0c 	lw r2,(r5+12)
 2000ba8:	4c 82 00 03 	bge r4,r2,2000bb4 <EE_buffer_getmsg+0x68>
 2000bac:	28 a3 00 00 	lw r3,(r5+0)
 2000bb0:	e3 ff ff f5 	bi 2000b84 <EE_buffer_getmsg+0x38>
 2000bb4:	28 a3 00 00 	lw r3,(r5+0)
    		msg[i] = buf(buf->g,i);				//buf->data[buf->g][i];
  		buf->g++;
  		if(buf->g == buf->buf_size)
 2000bb8:	28 a2 00 10 	lw r2,(r5+16)
		retvalue = EE_BUF_ERR_EMPTY; 
	else
	{	
  		for(i=0;i<(buf->msg_size);i++)	
    		msg[i] = buf(buf->g,i);				//buf->data[buf->g][i];
  		buf->g++;
 2000bbc:	34 61 00 01 	addi r1,r3,1
 2000bc0:	58 a1 00 00 	sw (r5+0),r1
  		if(buf->g == buf->buf_size)
 2000bc4:	44 22 00 10 	be r1,r2,2000c04 <EE_buffer_getmsg+0xb8>
  			buf->g = 0;							//buf->g = (buf->g % (buf->buf_size));
  		buf->counter--;
 2000bc8:	28 a1 00 08 	lw r1,(r5+8)
 2000bcc:	34 02 00 00 	mvi r2,0
 2000bd0:	34 21 ff ff 	addi r1,r1,-1
 2000bd4:	58 a1 00 08 	sw (r5+8),r1
  		retvalue = EE_BUF_OK;
	}
  	if (EE_mico32_are_IRQs_enabled(intst))		//EE_hal_enableIRQ();
 2000bd8:	20 e1 00 01 	andi r1,r7,0x1
 2000bdc:	44 20 00 04 	be r1,r0,2000bec <EE_buffer_getmsg+0xa0>
 * Enable interrupts
 */
__INLINE__ void __ALWAYS_INLINE__ EE_mico32_enableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 2000be0:	90 00 08 00 	rcsr r1,IE
    newie = oldie | (0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 2000be4:	38 21 00 01 	ori r1,r1,0x1
 2000be8:	d0 01 00 00 	wcsr IE,r1
        EE_mico32_enableIRQ();
  	
  	return retvalue;
}
 2000bec:	b8 40 08 00 	mv r1,r2
 2000bf0:	c3 a0 00 00 	ret
	
	if(msg==NULL)
		return EE_BUF_ERR_NULL;
	
	intst = EE_mico32_disableIRQ();				//EE_hal_disableIRQ();
	if((buf->g == buf->p) && (buf->counter==0)) 
 2000bf4:	28 a1 00 08 	lw r1,(r5+8)
 2000bf8:	34 02 ff fd 	mvi r2,-3
 2000bfc:	44 20 ff f7 	be r1,r0,2000bd8 <EE_buffer_getmsg+0x8c>
 2000c00:	e3 ff ff de 	bi 2000b78 <EE_buffer_getmsg+0x2c>
	{	
  		for(i=0;i<(buf->msg_size);i++)	
    		msg[i] = buf(buf->g,i);				//buf->data[buf->g][i];
  		buf->g++;
  		if(buf->g == buf->buf_size)
  			buf->g = 0;							//buf->g = (buf->g % (buf->buf_size));
 2000c04:	34 01 00 00 	mvi r1,0
 2000c08:	58 a1 00 00 	sw (r5+0),r1
 2000c0c:	e3 ff ff ef 	bi 2000bc8 <EE_buffer_getmsg+0x7c>

02000c10 <EE_std_run_task_code>:

/* This version should work for both the monostack and multistack versions of
 * the kernel, thanks to the macros defined in cpu/commmon/inc/ee_context.h.
 * In the mono version, all the stack-related stuff is ignored. */
EE_TID EE_std_run_task_code(EE_TID tid)
{
 2000c10:	37 9c ff fc 	addi sp,sp,-4
 2000c14:	5b 9d 00 04 	sw (sp+4),ra
 * Enable interrupts
 */
__INLINE__ void __ALWAYS_INLINE__ EE_mico32_enableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 2000c18:	90 00 10 00 	rcsr r2,IE
    newie = oldie | (0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 2000c1c:	38 42 00 01 	ori r2,r2,0x1
 2000c20:	d0 02 00 00 	wcsr IE,r2
    EE_hal_enableIRQ();
    EE_call_task_body(tid); /* Call the task body */
 2000c24:	78 02 02 00 	mvhi r2,0x200
 2000c28:	3c 21 00 02 	sli r1,r1,2
 2000c2c:	38 42 0e 78 	ori r2,r2,0xe78
 2000c30:	b4 41 10 00 	add r2,r2,r1
 2000c34:	28 43 00 00 	lw r3,(r2+0)
 2000c38:	d8 60 00 00 	call r3
 * Disable interrupts
 */
__INLINE__ EE_FREG __ALWAYS_INLINE__ EE_mico32_disableIRQ(void)
{
    EE_FREG oldie, newie;
    asm volatile ("rcsr %0,ie":"=r"(oldie));
 2000c3c:	90 00 08 00 	rcsr r1,IE
    newie = oldie & (~0x1);
    asm volatile ("wcsr ie, %0"::"r"(newie));
 2000c40:	34 02 ff fe 	mvi r2,-2
 2000c44:	a0 22 08 00 	and r1,r1,r2
 2000c48:	d0 01 00 00 	wcsr IE,r1
    EE_hal_disableIRQ();
    EE_thread_end_instance(); /* Call the scheduler */
 2000c4c:	f8 00 00 30 	calli 2000d0c <EE_thread_end_instance>
 2000c50:	78 02 02 00 	mvhi r2,0x200
 2000c54:	38 42 11 f0 	ori r2,r2,0x11f0
    return EE_std_endcycle_next_tid;
}
 2000c58:	28 41 00 00 	lw r1,(r2+0)
 2000c5c:	2b 9d 00 04 	lw ra,(sp+4)
 2000c60:	37 9c 00 04 	addi sp,sp,4
 2000c64:	c3 a0 00 00 	ret

02000c68 <EE_rq_insert>:
#include "ee_internal.h"

#ifndef __PRIVATE_RQ_INSERT__
// this function inserts a task into the ready queue
void EE_rq_insert(EE_TID t)
{
 2000c68:	37 9c ff fc 	addi sp,sp,-4
 2000c6c:	5b 8b 00 04 	sw (sp+4),r11
  EE_TYPEPRIO prio;
  EE_TID p,q;

  p = EE_NIL;
  q = EE_rqfirst;
 2000c70:	78 03 02 00 	mvhi r3,0x200
 2000c74:	38 63 0e 98 	ori r3,r3,0xe98
  prio = EE_th_ready_prio[t];
 2000c78:	78 06 02 00 	mvhi r6,0x200
 2000c7c:	3c 2b 00 02 	sli r11,r1,2
{
  EE_TYPEPRIO prio;
  EE_TID p,q;

  p = EE_NIL;
  q = EE_rqfirst;
 2000c80:	28 67 00 00 	lw r7,(r3+0)
  prio = EE_th_ready_prio[t];
 2000c84:	38 c6 0e 7c 	ori r6,r6,0xe7c
#include "ee_internal.h"

#ifndef __PRIVATE_RQ_INSERT__
// this function inserts a task into the ready queue
void EE_rq_insert(EE_TID t)
{
 2000c88:	b8 20 50 00 	mv r10,r1

  p = EE_NIL;
  q = EE_rqfirst;
  prio = EE_th_ready_prio[t];

  while ((q != EE_NIL) && (prio <= EE_th_ready_prio[q])) {
 2000c8c:	34 09 ff ff 	mvi r9,-1
  EE_TYPEPRIO prio;
  EE_TID p,q;

  p = EE_NIL;
  q = EE_rqfirst;
  prio = EE_th_ready_prio[t];
 2000c90:	b4 cb 08 00 	add r1,r6,r11
 2000c94:	28 28 00 00 	lw r8,(r1+0)

  while ((q != EE_NIL) && (prio <= EE_th_ready_prio[q])) {
 2000c98:	44 e9 00 19 	be r7,r9,2000cfc <EE_rq_insert+0x94>
 2000c9c:	3c e4 00 02 	sli r4,r7,2
 2000ca0:	b4 c4 08 00 	add r1,r6,r4
 2000ca4:	28 22 00 00 	lw r2,(r1+0)
 2000ca8:	55 02 00 15 	bgu r8,r2,2000cfc <EE_rq_insert+0x94>
 2000cac:	78 05 02 00 	mvhi r5,0x200
 2000cb0:	38 a5 0e 90 	ori r5,r5,0xe90
 2000cb4:	e0 00 00 05 	bi 2000cc8 <EE_rq_insert+0x60>
 2000cb8:	b4 c4 08 00 	add r1,r6,r4
 2000cbc:	28 22 00 00 	lw r2,(r1+0)
 2000cc0:	55 02 00 06 	bgu r8,r2,2000cd8 <EE_rq_insert+0x70>
 2000cc4:	b8 60 38 00 	mv r7,r3
    p = q;
    q = EE_th_next[q];
 2000cc8:	b4 a4 08 00 	add r1,r5,r4
 2000ccc:	28 23 00 00 	lw r3,(r1+0)

  p = EE_NIL;
  q = EE_rqfirst;
  prio = EE_th_ready_prio[t];

  while ((q != EE_NIL) && (prio <= EE_th_ready_prio[q])) {
 2000cd0:	3c 64 00 02 	sli r4,r3,2
 2000cd4:	5c 69 ff f9 	bne r3,r9,2000cb8 <EE_rq_insert+0x50>
    p = q;
    q = EE_th_next[q];
  }

  if (p != EE_NIL)
    EE_th_next[p] = t;
 2000cd8:	3c e1 00 02 	sli r1,r7,2

  p = EE_NIL;
  q = EE_rqfirst;
  prio = EE_th_ready_prio[t];

  while ((q != EE_NIL) && (prio <= EE_th_ready_prio[q])) {
 2000cdc:	b8 60 38 00 	mv r7,r3
    p = q;
    q = EE_th_next[q];
  }

  if (p != EE_NIL)
    EE_th_next[p] = t;
 2000ce0:	b4 a1 08 00 	add r1,r5,r1
 2000ce4:	58 2a 00 00 	sw (r1+0),r10
  else
    EE_rqfirst = t;

  EE_th_next[t] = q;
 2000ce8:	b4 ab 08 00 	add r1,r5,r11
 2000cec:	58 27 00 00 	sw (r1+0),r7
}
 2000cf0:	2b 8b 00 04 	lw r11,(sp+4)
 2000cf4:	37 9c 00 04 	addi sp,sp,4
 2000cf8:	c3 a0 00 00 	ret
 2000cfc:	78 05 02 00 	mvhi r5,0x200
  }

  if (p != EE_NIL)
    EE_th_next[p] = t;
  else
    EE_rqfirst = t;
 2000d00:	58 6a 00 00 	sw (r3+0),r10
 2000d04:	38 a5 0e 90 	ori r5,r5,0xe90
 2000d08:	e3 ff ff f8 	bi 2000ce8 <EE_rq_insert+0x80>

02000d0c <EE_thread_end_instance>:

#include "ee_internal.h"

#ifndef __PRIVATE_THREAD_END_INSTANCE__
void EE_thread_end_instance(void)
{
 2000d0c:	37 9c ff ec 	addi sp,sp,-20
 2000d10:	5b 8b 00 14 	sw (sp+20),r11
 2000d14:	5b 8c 00 10 	sw (sp+16),r12
 2000d18:	5b 8d 00 0c 	sw (sp+12),r13
 2000d1c:	5b 8e 00 08 	sw (sp+8),r14
 2000d20:	5b 9d 00 04 	sw (sp+4),ra

/* return the first stacked task (the running task) without extracting it */
#ifndef __PRIVATE_STK_QUERYFIRST__
__INLINE__ EE_TID __ALWAYS_INLINE__ EE_stk_queryfirst(void)
{
    return EE_stkfirst;  
 2000d24:	78 0d 02 00 	mvhi r13,0x200
 2000d28:	39 ad 0e 94 	ori r13,r13,0xe94
 2000d2c:	29 a7 00 00 	lw r7,(r13+0)
   * suspended!!! */
  EE_th_status[current] = EE_READY;
#endif
  
  /* reset the task priority bit in the system_ceiling */
  EE_sys_ceiling &= ~EE_th_dispatch_prio[current];
 2000d30:	78 0e 02 00 	mvhi r14,0x200
 2000d34:	39 ce 0e 80 	ori r14,r14,0xe80
  EE_TID current;
  
  current = EE_stk_queryfirst();
  
  /* decrease the pending activations... ready or stacked => (nact>0) */
  EE_th_nact[current]--;
 2000d38:	3c e3 00 02 	sli r3,r7,2
 2000d3c:	78 04 02 00 	mvhi r4,0x200
   * suspended!!! */
  EE_th_status[current] = EE_READY;
#endif
  
  /* reset the task priority bit in the system_ceiling */
  EE_sys_ceiling &= ~EE_th_dispatch_prio[current];
 2000d40:	b5 c3 08 00 	add r1,r14,r3
 2000d44:	28 22 00 00 	lw r2,(r1+0)

/* extract the running task from the stack */
#ifndef __PRIVATE_STK_GETFIRST__
__INLINE__ void __ALWAYS_INLINE__ EE_stk_getfirst(void)
{
    EE_stkfirst = EE_th_next[EE_stkfirst];
 2000d48:	78 01 02 00 	mvhi r1,0x200
  EE_TID current;
  
  current = EE_stk_queryfirst();
  
  /* decrease the pending activations... ready or stacked => (nact>0) */
  EE_th_nact[current]--;
 2000d4c:	38 84 11 60 	ori r4,r4,0x1160
   * suspended!!! */
  EE_th_status[current] = EE_READY;
#endif
  
  /* reset the task priority bit in the system_ceiling */
  EE_sys_ceiling &= ~EE_th_dispatch_prio[current];
 2000d50:	78 0c 02 00 	mvhi r12,0x200
 2000d54:	38 21 0e 90 	ori r1,r1,0xe90
  EE_TID current;
  
  current = EE_stk_queryfirst();
  
  /* decrease the pending activations... ready or stacked => (nact>0) */
  EE_th_nact[current]--;
 2000d58:	b4 83 20 00 	add r4,r4,r3
   * suspended!!! */
  EE_th_status[current] = EE_READY;
#endif
  
  /* reset the task priority bit in the system_ceiling */
  EE_sys_ceiling &= ~EE_th_dispatch_prio[current];
 2000d5c:	39 8c 11 54 	ori r12,r12,0x1154
 2000d60:	b4 23 08 00 	add r1,r1,r3
  EE_TID current;
  
  current = EE_stk_queryfirst();
  
  /* decrease the pending activations... ready or stacked => (nact>0) */
  EE_th_nact[current]--;
 2000d64:	28 85 00 00 	lw r5,(r4+0)
   * suspended!!! */
  EE_th_status[current] = EE_READY;
#endif
  
  /* reset the task priority bit in the system_ceiling */
  EE_sys_ceiling &= ~EE_th_dispatch_prio[current];
 2000d68:	29 86 00 00 	lw r6,(r12+0)
 2000d6c:	28 21 00 00 	lw r1,(r1+0)
  
#if defined(__MULTI__) || defined(__WITH_STATUS__)
  /* The task state switches from STACKED TO READY because it ends its
   * instance. Note that status=READY and nact=0 ==>> the task is
   * suspended!!! */
  EE_th_status[current] = EE_READY;
 2000d70:	78 0b 02 00 	mvhi r11,0x200
 2000d74:	39 6b 0e 8c 	ori r11,r11,0xe8c
#endif
  
  /* reset the task priority bit in the system_ceiling */
  EE_sys_ceiling &= ~EE_th_dispatch_prio[current];
 2000d78:	a4 40 10 00 	not r2,r2
 2000d7c:	a0 46 10 00 	and r2,r2,r6
 2000d80:	59 a1 00 00 	sw (r13+0),r1
  EE_TID current;
  
  current = EE_stk_queryfirst();
  
  /* decrease the pending activations... ready or stacked => (nact>0) */
  EE_th_nact[current]--;
 2000d84:	34 a5 ff ff 	addi r5,r5,-1
  
#if defined(__MULTI__) || defined(__WITH_STATUS__)
  /* The task state switches from STACKED TO READY because it ends its
   * instance. Note that status=READY and nact=0 ==>> the task is
   * suspended!!! */
  EE_th_status[current] = EE_READY;
 2000d88:	b5 63 18 00 	add r3,r11,r3
 2000d8c:	34 01 00 01 	mvi r1,1
 2000d90:	58 61 00 00 	sw (r3+0),r1
  EE_TID current;
  
  current = EE_stk_queryfirst();
  
  /* decrease the pending activations... ready or stacked => (nact>0) */
  EE_th_nact[current]--;
 2000d94:	58 85 00 00 	sw (r4+0),r5
   * suspended!!! */
  EE_th_status[current] = EE_READY;
#endif
  
  /* reset the task priority bit in the system_ceiling */
  EE_sys_ceiling &= ~EE_th_dispatch_prio[current];
 2000d98:	59 82 00 00 	sw (r12+0),r2
  
  /* extract the task from the stk data structure */
  EE_stk_getfirst();
  
  if (EE_th_nact[current] > 0) {
 2000d9c:	5c a0 00 30 	bne r5,r0,2000e5c <EE_thread_end_instance+0x150>

/* return the first ready task without extracting it */
#ifndef __PRIVATE_RQ_QUERYFIRST__
__INLINE__ EE_TID __ALWAYS_INLINE__ EE_rq_queryfirst(void)
{
    return EE_rqfirst;  
 2000da0:	78 01 02 00 	mvhi r1,0x200
 2000da4:	38 21 0e 98 	ori r1,r1,0xe98
 2000da8:	28 21 00 00 	lw r1,(r1+0)
    EE_rq_insert(current);
  }
  
  /* check if there is to schedule a ready task pop a preempted
   * task   */
  if (EE_rq_queryfirst() == EE_NIL ||
 2000dac:	34 02 ff ff 	mvi r2,-1
 2000db0:	44 22 00 08 	be r1,r2,2000dd0 <EE_thread_end_instance+0xc4>
 2000db4:	3c 23 00 02 	sli r3,r1,2
 2000db8:	78 01 02 00 	mvhi r1,0x200
 2000dbc:	38 21 0e 7c 	ori r1,r1,0xe7c
 2000dc0:	b4 23 08 00 	add r1,r1,r3
 2000dc4:	28 22 00 00 	lw r2,(r1+0)
 2000dc8:	29 85 00 00 	lw r5,(r12+0)
 2000dcc:	54 45 00 0f 	bgu r2,r5,2000e08 <EE_thread_end_instance+0xfc>
}


__INLINE__ void __ALWAYS_INLINE__ EE_hal_endcycle_stacked(EE_TID tid)
{
    EE_std_endcycle_next_tid = EE_std_mark_tid_stacked(tid);
 2000dd0:	29 a1 00 00 	lw r1,(r13+0)
      EE_hal_endcycle_ready(EE_rq2stk_exchange());
#else
    EE_hal_endcycle_ready(EE_rq2stk_exchange());
#endif
  }
}  
 2000dd4:	78 02 80 00 	mvhi r2,0x8000
 2000dd8:	38 42 00 00 	ori r2,r2,0x0
 2000ddc:	78 03 02 00 	mvhi r3,0x200
 2000de0:	b8 22 08 00 	or r1,r1,r2
 2000de4:	38 63 11 f0 	ori r3,r3,0x11f0
 2000de8:	58 61 00 00 	sw (r3+0),r1
 2000dec:	2b 9d 00 04 	lw ra,(sp+4)
 2000df0:	2b 8b 00 14 	lw r11,(sp+20)
 2000df4:	2b 8c 00 10 	lw r12,(sp+16)
 2000df8:	2b 8d 00 0c 	lw r13,(sp+12)
 2000dfc:	2b 8e 00 08 	lw r14,(sp+8)
 2000e00:	37 9c 00 14 	addi sp,sp,20
 2000e04:	c3 a0 00 00 	ret
    
#if defined(__MULTI__) || defined(__WITH_STATUS__)
    EE_th_status[EE_rq_queryfirst()] = EE_STACKED;
#endif

    EE_sys_ceiling |= EE_th_dispatch_prio[EE_rq_queryfirst()];
 2000e08:	b5 c3 08 00 	add r1,r14,r3
  else { 
    /* we have to schedule a ready task */
#if defined(__MULTI__)
    register int flag;
    
    flag = EE_th_status[EE_rq_queryfirst()] & EE_WASSTACKED;
 2000e0c:	b5 63 20 00 	add r4,r11,r3
    
#if defined(__MULTI__) || defined(__WITH_STATUS__)
    EE_th_status[EE_rq_queryfirst()] = EE_STACKED;
#endif

    EE_sys_ceiling |= EE_th_dispatch_prio[EE_rq_queryfirst()];
 2000e10:	28 22 00 00 	lw r2,(r1+0)
  else { 
    /* we have to schedule a ready task */
#if defined(__MULTI__)
    register int flag;
    
    flag = EE_th_status[EE_rq_queryfirst()] & EE_WASSTACKED;
 2000e14:	28 83 00 00 	lw r3,(r4+0)
#endif
    
#if defined(__MULTI__) || defined(__WITH_STATUS__)
    EE_th_status[EE_rq_queryfirst()] = EE_STACKED;
 2000e18:	34 01 00 02 	mvi r1,2
#endif

    EE_sys_ceiling |= EE_th_dispatch_prio[EE_rq_queryfirst()];
 2000e1c:	b8 45 10 00 	or r2,r2,r5
    
    flag = EE_th_status[EE_rq_queryfirst()] & EE_WASSTACKED;
#endif
    
#if defined(__MULTI__) || defined(__WITH_STATUS__)
    EE_th_status[EE_rq_queryfirst()] = EE_STACKED;
 2000e20:	58 81 00 00 	sw (r4+0),r1
#endif

    EE_sys_ceiling |= EE_th_dispatch_prio[EE_rq_queryfirst()];
 2000e24:	59 82 00 00 	sw (r12+0),r2
  else { 
    /* we have to schedule a ready task */
#if defined(__MULTI__)
    register int flag;
    
    flag = EE_th_status[EE_rq_queryfirst()] & EE_WASSTACKED;
 2000e28:	20 63 00 08 	andi r3,r3,0x8
#endif

    EE_sys_ceiling |= EE_th_dispatch_prio[EE_rq_queryfirst()];

#if defined(__MULTI__)
    if (flag)
 2000e2c:	5c 60 00 0f 	bne r3,r0,2000e68 <EE_thread_end_instance+0x15c>
      EE_hal_endcycle_stacked(EE_rq2stk_exchange());
    else
      EE_hal_endcycle_ready(EE_rq2stk_exchange());
 2000e30:	fb ff fd e0 	calli 20005b0 <EE_rq2stk_exchange>
}


__INLINE__ void __ALWAYS_INLINE__ EE_hal_endcycle_ready(EE_TID tid)
{
    EE_std_endcycle_next_tid = tid;
 2000e34:	78 02 02 00 	mvhi r2,0x200
 2000e38:	38 42 11 f0 	ori r2,r2,0x11f0
 2000e3c:	58 41 00 00 	sw (r2+0),r1
#else
    EE_hal_endcycle_ready(EE_rq2stk_exchange());
#endif
  }
}  
 2000e40:	2b 9d 00 04 	lw ra,(sp+4)
 2000e44:	2b 8b 00 14 	lw r11,(sp+20)
 2000e48:	2b 8c 00 10 	lw r12,(sp+16)
 2000e4c:	2b 8d 00 0c 	lw r13,(sp+12)
 2000e50:	2b 8e 00 08 	lw r14,(sp+8)
 2000e54:	37 9c 00 14 	addi sp,sp,20
 2000e58:	c3 a0 00 00 	ret
  
  if (EE_th_nact[current] > 0) {
    /* there are pending activations...  */
    /* we have to reinsert the task into the ready queue before
     * rescheduling!!! */
    EE_rq_insert(current);
 2000e5c:	b8 e0 08 00 	mv r1,r7
 2000e60:	fb ff ff 82 	calli 2000c68 <EE_rq_insert>
 2000e64:	e3 ff ff cf 	bi 2000da0 <EE_thread_end_instance+0x94>

    EE_sys_ceiling |= EE_th_dispatch_prio[EE_rq_queryfirst()];

#if defined(__MULTI__)
    if (flag)
      EE_hal_endcycle_stacked(EE_rq2stk_exchange());
 2000e68:	fb ff fd d2 	calli 20005b0 <EE_rq2stk_exchange>
 2000e6c:	e3 ff ff da 	bi 2000dd4 <EE_thread_end_instance+0xc8>

02000e70 <_exit>:
 2000e70:	34 08 00 01 	mvi r8,1
 2000e74:	ac 00 00 07 	scall
