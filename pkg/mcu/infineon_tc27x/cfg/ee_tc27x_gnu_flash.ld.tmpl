/*
 * Name: ee_tc27xgnu_flash.ld 
 * 
 * Description: 
 * Linker rules for internal Flash configuration
 */
/* Slaves' entry points */
EE_tc27x_cpu1_start = 0x80206300;
EE_tc27x_cpu2_start = 0x80306300;

SECTIONS
{
  /*
   * The startup code should be placed where the CPU expects it after a reset,
   * so we try to locate it first, no matter where it appears in the list of
   * objects and libraries (note: because the wildcard pattern doesn't match
   * directories, we'll try to find crt0.o in various (sub)directories).
   */

  /*
  .reset (0x80000000) :
  {
    BootModeIndex = .;
    LONG (0x00000000);
    LONG (0xb3590070);
    LONG (0x00000000);
    LONG (0x00000000);
    LONG (0x00000000);
    LONG (0x00000000);
    LONG (0x791eb864);
    LONG (0x86e1479b);
  } > PMU_PFLASH_STARTUP */

  .startup  :
  {
    BootModeIndex = .;
    PROVIDE(__startup_code_start = .);
    KEEP (*(.startup_code))
    KEEP (*(ee_kernel_start))
    . = ALIGN(8);
    PROVIDE(__startup_code_end = .);
  } > PMU_PFLASH_STARTUP

  /*
   * Allocate .text and other read-only sections.
   */

  /*
   * Code executed before calling main
   */
  .init :
  {
    *(.init)
    *(.fini)
    . = ALIGN(8);
  } > PMU_PFLASH

  .cramtext :
  {
    *(.cramtext)
    *(.cramtext.*)
    . = ALIGN(8);
  } > PMI_PSPR AT> PMU_PFLASH

  /*
   * Section for trap table
   */
  .traptab  :
  {
    PROVIDE(__traptab_start = .);

    KEEP(*(.traptab))   /*Section for trap table*/ 
    KEEP(*(.traptab*))

    PROVIDE(__traptab_end = .);
    . = ALIGN(8);
    
  } > PMU_PFLASH
  
  /*
   * Section for interrupt table
   */
  .inttab  :
  {
    PROVIDE(__inttab_start = .);
    KEEP (*(.inttab));
    KEEP (*(.*.inttab));
    PROVIDE(__inttab_end = .);
    . = ALIGN(8);
  } > PMU_PFLASH

  /*
   * Code sections
   */
  EE_tc27x_cpu1_start (0x80206300) :
  {
    KEEP(*(*.EE_tc27x_cpu1_start))
    . = ALIGN(8);
  }

  EE_tc27x_cpu2_start (0x80306300) :
  {
    KEEP(*(*.EE_tc27x_cpu2_start))
    . = ALIGN(8);
  }

  /* Global section to share code symbol between cores */
  ee_mcglobalt  :
  {
    KEEP(*(*.StartupHook))
    KEEP(*(*.ErrorHook))
    KEEP(*(*.ShutdownHook))
    /* KEEP(*(*.PreTaskHook)) */
    /* KEEP(*(*.PostTaskHook)) */
    KEEP(*(*.ProtectionHook))
    KEEP(*(ee_mcglobalt))
  } > PMU_PFLASH

  .text : ALIGN(8)
  {
    PROVIDE(__text_start = .);
    *(.text)
    *(.text.*)
    *(.gnu.linkonce.t.*)
    /*
     * .gnu.warning sections are handled specially by elf32.em.
     */
    *(.gnu.warning)

    . = ALIGN(8);
  } > PMU_PFLASH

  /* OS Public Code */
  ee_api_text : ALIGN(8) {
    /* range section have to be aligned to 8 bytes */
    PROVIDE(ee_stext_api = . );
    *(ee_api_text)
    /* ALIGN(8) is needed because Range Addresses have to be aligned
       to 8 byte. */
    . += 1;
    . = ALIGN(8);
    /* End OS-Application Data Section Symbol */
    PROVIDE(ee_etext_api = . );
    /* ALIGN(16) the begin of OS_Application data and the following do the
       trick to move next OS-Application section 16 byte forward (at least) */
    . += 15;
    /* Each PMU_PFLASH region have to be at least 4 ALIGNED to ensure that LMA
       region (Load Memory Address) for data region are valid for __copy_table
     */
    . = ALIGN(8);
  } > PMU_PFLASH

  /* OS Private Code */
  ee_kernel_text : ALIGN(16) {
    /* The begin of the kernel code section is aligned to 16 to
       ensure space requiremente for cross sections access protection.
       (Read the Note: at page 9-5 of
       TC_Architecture_vol1_TC161_TCS_TC16P_TC16E.pdf manual) */
    PROVIDE(ee_stext_kernel = . );
    *(ee_kernel_text)
    /* ALIGN(8) is needed because Range Addresses have to be aligned
       to 8 byte. */
    . += 1;
    . = ALIGN(8);
    /* End OS-Application Data Section Symbol */
    PROVIDE(ee_etext_kernel = . );
    /* ALIGN(16) the begin of OS_Application data and the following do the
       trick to move next OS-Application section 16 byte forward (at least) */
    . += 15;
    /* Each PMU_PFLASH region have to be at least 4 ALIGNED to ensure that LMA
       region (Load Memory Address) for data region are valid for __copy_table
     */
    . = ALIGN(8);
  } > PMU_PFLASH

  /* GENERATED APPLICATION CODE SECTIONS - BEGIN */
FOR_EACH_APP
  /* OS-Application Private Code */
  ee_${APP_NAME}_text : {
    /* The begin of an OS-Application section code is aligned to 16 to
       ensure space requiremente for cross sections access protection.
       (Read the Note: at page 9-5 of
       TC_Architecture_vol1_TC161_TCS_TC16P_TC16E.pdf manual) */
    . = ALIGN(16);
    PROVIDE(ee_stext_${APP_NAME} = . );
    *(ee_${APP_NAME}_text)
    /* ALIGN(8) is needed because Range Addresses have to be aligned
       to 8 byte. */
    . += 1;
    . = ALIGN(8);
    /* End OS-Application Data Section Symbol */
    PROVIDE(ee_etext_${APP_NAME} = . );
    /* ALIGN(16) the begin of OS_Application data and the following do the
       trick to move next OS-Application section 16 byte forward (at least) */
    . += 15;
    /* Each PMU_PFLASH region have to be at least 4 ALIGNED to ensure that LMA
       region (Load Memory Address) for data region are valid for __copy_table
     */
    . = ALIGN(4);
  } > PMU_PFLASH
END_EACH_APP
  /* GENERATED APPLICATION CODE SECTIONS - END */

  /*
   * C++ exception handling tables.  NOTE: gcc emits .eh_frame
   * sections when compiling C sources with debugging enabled (-g).
   * If you can be sure that your final application consists
   * exclusively of C objects (i.e., no C++ objects), you may use
   * the -R option of the "strip" and "objcopy" utilities to remove
   * the .eh_frame section from the executable.
   */
  .eh_frame  :
  {
    *(.gcc_except_table)
    __EH_FRAME_BEGIN__ = . ;
    KEEP (*(.eh_frame))
    __EH_FRAME_END__ = . ;
    *(.jcr)
    . = ALIGN(8);
  } > PMU_PFLASH

  /*
   * Constructors and destructors.
   */
  .ctors :
  {
    __CTOR_LIST__ = . ;
    LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2);
    *(.ctors)
    LONG(0) ;
    __CTOR_END__ = . ;
    . = ALIGN(8);
  } > PMU_PFLASH

  .dtors :
  {
    __DTOR_LIST__ = . ;
    LONG((__DTOR_END__ - __DTOR_LIST__) / 4 - 2);
    *(.dtors)
    LONG(0) ;
    __DTOR_END__ = . ;
    . = ALIGN(8);
  } > PMU_PFLASH

  /*
   * Storage of write-protected data
   */
  /* Erika Constant Shared Data */
  ee_mcglobalc  :
  {
    KEEP(*(ee_mcglobalc))
    . = ALIGN(8);
  } > PMU_PFLASH

  .rodata  :
  {
    PROVIDE(__rodata_start = .);

    *(.rodata)
    *(.rodata.*)
    *(.gnu.linkonce.r.*)
    *(.rodata1)
    *(.toc)
    /*
     * Create the clear and copy tables that tell the startup code
     * which memory areas to clear and to copy, respectively.
     */
    /* make sure that __clear_table do not coincide with the last const data.
       ALIGN(8) because range addresses have to be 8 bytes aligned */
    . += 1;
    . = ALIGN(8);
    PROVIDE(__clear_table = .) ;
    LONG(0 + ADDR(.bss));     LONG(SIZEOF(.bss));
    LONG(0 + ADDR(.sbss));    LONG(SIZEOF(.sbss));
    LONG(0 + ADDR(.zbss));    LONG(SIZEOF(.zbss));
    LONG(0 + ADDR(ee_api_bss)); LONG(SIZEOF(ee_api_bss));
    LONG(0 + ADDR(ee_kernel_bss)); LONG(SIZEOF(ee_kernel_bss));
/* GENERATED OS APPLICATION CLEAR TABLE - BEGIN */
FOR_EACH_APP
    LONG(0 + ADDR(ee_${APP_NAME}_bss)); LONG(SIZEOF(ee_${APP_NAME}_bss));
END_EACH_APP
/* GENERATED OS APPLICATION CLEAR TABLE - END */
    LONG(-1);                 LONG(-1);

    . = ALIGN(4);
    PROVIDE(__copy_table = .) ;
    LONG(LOADADDR(.data));    LONG(0 + ADDR(.data));    LONG(SIZEOF(.data));
    LONG(LOADADDR(.sdata));   LONG(0 + ADDR(.sdata));   LONG(SIZEOF(.sdata));
    LONG(LOADADDR(.zdata));   LONG(0 + ADDR(.zdata));   LONG(SIZEOF(.zdata));
    LONG(LOADADDR(.cramtext)); LONG(0 + ADDR(.cramtext)); LONG(SIZEOF(.cramtext));
    LONG(LOADADDR(ee_api_data)); LONG(0 + ADDR(ee_api_data)); LONG(SIZEOF(ee_api_data));
    LONG(LOADADDR(ee_kernel_data)); LONG(0 + ADDR(ee_kernel_data)); LONG(SIZEOF(ee_kernel_data));
    LONG(LOADADDR(ee_mcglobald)); LONG(0 + ADDR(ee_mcglobald)); LONG(SIZEOF(ee_mcglobald));
/* GENERATED OS APPLICATION INITIALIZATION TABLE - BEGIN */
FOR_EACH_APP
    LONG(LOADADDR(ee_${APP_NAME}_data)); LONG(0 + ADDR(ee_${APP_NAME}_data)); LONG(SIZEOF(ee_${APP_NAME}_data));
END_EACH_APP
/* GENERATED OS APPLICATION INITIALIZATION TABLE - END */
    LONG(-1);                 LONG(-1);                 LONG(-1);

    . = ALIGN(4) ;
    PROVIDE(ee_stacks_table = .) ;
    LONG(0 + ADDR(ee_kernel_stack)); LONG(SIZEOF(ee_kernel_stack));
/* GENERATED STACKS - BEGIN */
FOR_EACH_APP
    LONG(0 + ADDR(ee_${APP_NAME}_stack)); LONG(SIZEOF(ee_${APP_NAME}_stack));
END_EACH_APP
/* GENERATED STACKS TABLE - END */
    LONG(-1);                 LONG(-1);
    /* ALIGN(8) because range addresses have to be 8 bytes aligned */
    . = ALIGN(8);
  } > PMU_PFLASH

  .sdata2  :
  {
    *(.sdata.rodata)
    *(.sdata.rodata.*)
    . = ALIGN(8);
  } > PMU_PFLASH

  /*
   * Allocate space for absolute addressable sections; this requires that
   * "int_dspr" starts at a TriCore segment (256M) and points to
   * some RAM area!  If these conditions are not met by your particular
   * hardware setup, you should either not use absolute data, or you
   * must move .zdata*,.zbss*,.bdata*,.bbss* input sections to some appropriate
   * memory area.
   */
  .zbss  (NOLOAD) :
  {
    ZBSS_BASE = . ;
    *(.zbss)
    *(.zbss.*)
    *(.gnu.linkonce.zb.*)
    *(.bbss)
    *(.bbss.*)
    . = ALIGN(8);
    ZBSS_END = . ;
  } > DMI_DSPR

  .zdata  :
  {
    ZDATA_BASE = . ;
    *(.zrodata)
    *(.zrodata.*)
    *(.zdata)
    *(.zdata.*)
    *(.gnu.linkonce.z.*)
    *(.bdata)
    *(.bdata.*)
    . = ALIGN(8);
    ZDATA_END = . ;
  } > DMI_DSPR AT> PMU_PFLASH

  /*
   * We're done now with the text part of the executable.  The
   * following sections are special in that their initial code or
   * data (if any) must also be stored in said text part of an
   * executable, but they "live" at completely different addresses
   * at runtime -- usually in RAM areas.  NOTE: This is not really
   * necessary if you use a special program loader (e.g., a debugger)
   * to load a complete executable consisting of code, data, BSS, etc.
   * into the RAM of some target hardware or a simulator, but it *is*
   * necessary if you want to burn your application into non-volatile
   * memories such as EPROM or FLASH.
   */

  /*
   * Not initialised data in section ’.sbss’, addressable by small data area pointer (%a0)
   */
  .sbss (NOLOAD) : FLAGS(aws)
  {
    PROVIDE(__sbss_start = .);
    *(.sbss)
    _CONFIG_BEGIN_ = .;
    *(.sbss.CONFIG)
    _CONFIG_END_ = .;
    *(.sbss.*)
    *(.gnu.linkonce.sb.*)
    PROVIDE(__sbss_end = .);
    . = ALIGN(8);
  } > DMI_DSPR /* DMI_DSPR: Local Data RAM (DSPR) */

  /*
   * Initialised data in section ’.sdata’, addressable by small data area pointer (%a0)
   */
   
  .sdata : FLAGS(awls)
  {
    . = ALIGN(8) ;
    SDATA_BASE = . ;
    PROVIDE(__sdata_start = .);
    *(.sdata)
    *(.sdata.*)
    *(.gnu.linkonce.s.*)
    . = ALIGN(8);
    SDATA_END = .;
    PROVIDE(__sdata_end = .);
  } > DMI_DSPR AT> PMU_PFLASH

  /*
   * Not Initialised data.
   * Allocate space for BSS sections.
   */
  .bss (NOLOAD) :
  {
    BSS_BASE = .;
    PROVIDE(__bss_start = .);
    *(.bss)
    *(.bss.*)
    *(.gnu.linkonce.b.*)
    *(COMMON)

    PROVIDE(__bss_end = .);
    . = ALIGN(8);
  } > DMI_DSPR /* DMI_DSPR: Local Data RAM (DSPR) */

  /*
   * Initialised data
   */
  .data : FLAGS(awl)
  {
    . = ALIGN(8) ;
    DATA_BASE = . ;
    PROVIDE(__data_start = .);
    *(.data)
    *(.data.*)
    *(.gnu.linkonce.d.*)
    SORT(CONSTRUCTORS)
    . = ALIGN(8) ;
    DATA_END = . ;
    PROVIDE(__data_end = .);
  } > DMI_DSPR AT> PMU_PFLASH

  /*
   * Section for ustack
   */  
  .ustack :
  {
    . = ALIGN(8);
     __USTACK_BEGIN = . ;
    . += __USTACK_SIZE ;
    . = ALIGN(8);
     __USTACK = . ;
     __USTACK_END = . ;
  } > DMI_DSPR

  /*
   * Section for istack
   */  
  .istack :
  {
    . = ALIGN(8);
     __ISTACK_BEGIN = . ;
    . += __ISTACK_SIZE ;
    . = ALIGN(8);
     __ISTACK = . ;
     __ISTACK_END = . ;
  } > DMI_DSPR
  
  /*
   * Section for heap
   */  
  .heap :
  {
    . = ALIGN(8);
     __HEAP_BEGIN = . ;
     __HEAP = . ;
    . += __HEAP_SIZE ;
    . = ALIGN(8);
     __HEAP_END = . ;
  } > DMI_DSPR
  
  /*
   * Section for CSA
   */  
  .csa :
  {
    . = ALIGN(64);
     __CSA_BEGIN = . ;
     __CSA = . ;
    . += __CSA_SIZE ;
    . = ALIGN(64);
     __CSA_END = . ;
  } > DMI_DSPR


  /* ERIKA API Sections */

  /* ERIKA API public unitializated data section */
  ee_api_bss :  ALIGN(8) {
    /* begin ERIKA API public unitializated data section symbol */
    PROVIDE(ee_sbss_api = .);
    *(ee_api_bss)
    PROVIDE(ee_ebss_api = .);
    . = ALIGN(8);
  } > DMI_DSPR

  /* ERIKA API public initializated data DATA */
  ee_api_data : ALIGN(8) FLAGS(awl) {
    PROVIDE(ee_sdata_api = .);
    *(ee_api_data)

    /* ALIGN(8) is needed because Range Addresses have to be aligned
       to 8 byte. */
    . += 1;
    . = ALIGN(8);
    /* End Erika API Data Section Symbol */
    PROVIDE(ee_edata_api = .);

    /* ALIGN(16) the begin of OS_Application data and the following do the
       trick to move next OS-Application section 16 byte forward (at least) */
    . += 15;
    /* Each data region have to be at least 4 ALIGNED to ensure that LMA
       region (Load Memory Address) for other data region are valid for
       __copy_table
     */
    . = ALIGN(8);

  } > DMI_DSPR AT> PMU_PFLASH


  /* ERIKA Kernel Sections */

  /* ERIKA Kernel private unitializated data section */
  ee_kernel_bss : ALIGN(8) {
    /* begin ERIKA Kernel private unitializated data section symbol */
    PROVIDE(ee_sbss_kernel = .);
    *(ee_kernel_bss)
    PROVIDE(ee_ebss_kernel = .);
  } > DMI_DSPR

  /* ERIKA Kernel private initializated data DATA */
  ee_kernel_data : ALIGN(8) FLAGS(awl) {
    PROVIDE(ee_sdata_kernel = .);
    *(ee_kernel_data)

    /* ALIGN(8) is needed because Range Addresses have to be aligned
       to 8 byte. */
    . += 1;
    . = ALIGN(8);
    /* End Erika Kernel Data Section Symbol */
    PROVIDE(ee_edata_kernel = .);

    /* ALIGN(16) the begin of OS_Application data and the following do the
       trick to move next OS-Application section 16 byte forward (at least) */
    . += 15;
    /* Each data region have to be at least 4 ALIGNED to ensure that LMA
       region (Load Memory Address) for other data region are valid for
       __copy_table
     */
    . = ALIGN(8);
  } > DMI_DSPR AT> PMU_PFLASH

  /* ERIKA Kenel Stacks (Don't belong to any OS-Applications, special section
     is needed to handle memory protection and stack monitoring) */
  ee_kernel_stack : ALIGN(8) {
    PROVIDE(ee_sstack_kernel = .);
    KEEP(*(ee_kernel_stack))
    /* Put the first OS-Application Section 16 forward respect the system
       sections to assure cross sections access protection.
       (Read the Note: at page 9-5 of
        TC_Architecture_vol1_TC161_TCS_TC16P_TC16E.pdf manual)
     */
    . += 15;
    . = ALIGN(8);
    /* each range address have to be 8 byte aligned */
    PROVIDE(ee_estack_kernel = .);
  } > DMI_DSPR

  /* GENERATED APPLICATION DATA SECTIONS - BEGIN */
FOR_EACH_APP

  /* Start OS-Application Data Section Symbol.
                          !!! WARNING !!!
                    I WILL IGNORE APP_BASE VALUE   */
  /* ee_ssec_${APP_NAME} = ${APP_BASE}; */

  /* OS-Application Section Private Stack */
  ee_${APP_NAME}_stack /* (${APP_BASE}) */ : ALIGN(16) {
    /* The begin of an OS-Application section "group" is aligned to 16 to
       ensure space requiremente for cross sections access protection.
       (Read the Note: at page 9-5 of
        TC_Architecture_vol1_TC161_TCS_TC16P_TC16E.pdf manual) */
    /* begin OS-Application Data Section Symbol */
    PROVIDE(ee_ssec_${APP_NAME} = .);
    /* The stack is put at the beginning of the application space,
     * so that stack overflows are caught by the memory */
    PROVIDE(ee_sstack_${APP_NAME} = .);
    *(ee_${APP_NAME}_stack)
    PROVIDE(ee_estack_${APP_NAME} = .);
  } > DMI_DSPR

  /* OS-Application Section Private Unitializated DATA */
  ee_${APP_NAME}_bss : ALIGN(4) {
    PROVIDE(ee_sbss_${APP_NAME} = .);
    *(ee_${APP_NAME}_bss)
    PROVIDE(ee_ebss_${APP_NAME} = .);
  } > DMI_DSPR

  /* OS-Application Section Private Initializated DATA */
  ee_${APP_NAME}_data : ALIGN(4) FLAGS(awl) {
    PROVIDE(ee_sdata_${APP_NAME} = .);
    *(ee_${APP_NAME}_data)
    PROVIDE(ee_edata_${APP_NAME} = .);

    /* ALIGN(8) is needed because Range Addresses have to be aligned
       to 8 byte. */
    . += 1;
    . = ALIGN(8);
    /* End OS-Application Data Section Symbol */
    PROVIDE(ee_esec_${APP_NAME} = .);

    /* ALIGN(16) the begin of OS_Application data and the following do the
       trick to move next OS-Application section 16 byte forward (at least) */
    . += 15;
    /* Each data region have to be at least 4 ALIGNED to ensure that LMA
       region (Load Memory Address) for other data region are valid for
       __copy_table
     */
    . = ALIGN(4);
  } > DMI_DSPR AT> PMU_PFLASH

  /* LOAD DATA Symbol (Unused ADDED for coherency with e200zx implementation) */
  /* PROVIDE(ee_load_data_${APP_NAME} = LOADADDR(ee_${APP_NAME}_data)); */

  /* Application Dimension Check Condition */
   _. = ASSERT(((ee_esec_${APP_NAME} <= ee_ssec_${APP_NAME} + ${APP_SIZE}) || (${APP_SIZE} == 0)), "${APP_NAME} size is bigger than reserved space");

END_EACH_APP
  /* GENERATED APPLICATION DATA SECTIONS - END */

  /* Erika RTOS Multicore global data */
  ee_mcglobald  : FLAGS(awl)
  {
    . = ALIGN(8);
    KEEP(*(ee_mcglobald))
  } > LMU_SRAM AT> PMU_PFLASH

  /* Special Section Used to Provide RAM, Flash an code Symbols */
  ee_end (NOLOAD) : {
    PROVIDE(ee_sall_code      = BootModeIndex);
    PROVIDE(ee_eall_code      = ADDR(.dtors) + SIZEOF(.dtors));

    PROVIDE(ee_skernel_ram    = __DMI_DSPR_BEGIN);
    PROVIDE(ee_ekernel_ram    = .);
    PROVIDE(ee_skernel_code   = ADDR(ee_kernel_text));
    PROVIDE(ee_ekernel_code   = ADDR(ee_kernel_text) + SIZEOF(ee_kernel_text));
    PROVIDE(ee_sapi_const     = ADDR(.rodata));
    PROVIDE(ee_eapi_const     = __clear_table);

    PROVIDE(ee_sapi_ram       = ADDR(ee_api_bss));
    PROVIDE(ee_eapi_ram       = ADDR(ee_api_bss) + SIZEOF(ee_api_bss));
    PROVIDE(ee_sapi_code      = ADDR(ee_api_text));
    PROVIDE(ee_eapi_code      = ADDR(ee_api_text) + SIZEOF(ee_api_text));
    /* Each PMU_PFLASH region have to be at least 4 ALIGNED to ensure that LMA
       region (Load Memory Address) for data region are valid for __copy_table
     */
    . = ALIGN(4);
  } > DMI_DSPR AT> PMU_PFLASH

  /* Make sure CSA, stack and heap addresses are properly aligned.  */
  _. = ASSERT (_START == 0x80000020, "_START is not in the right place");
  _. = ASSERT ((__CSA_BEGIN & 0x3f) == 0 , "illegal CSA start address") ;
  _. = ASSERT ((__CSA_SIZE & 0x3f) == 0 , "illegal CSA size") ;
  _. = ASSERT ((__ISTACK & 7) == 0 , "ISTACK not doubleword aligned") ;
  _. = ASSERT ((__USTACK & 7) == 0 , "USTACK not doubleword aligned") ;
  _. = ASSERT ((__HEAP_END & 7) == 0 , "HEAP not doubleword aligned") ;

  /* Define a default symbol for address 0.  */
  NULL = DEFINED (NULL) ? NULL : 0 ;

  /*
   * DWARF debug sections.
   * Symbols in the DWARF debugging sections are relative to the
   * beginning of the section, so we begin them at 0.
   */
  /*
   * DWARF 1
   */
  .comment         0 : { *(.comment) }
  .debug           0 : { *(.debug) }
  .line            0 : { *(.line) }
  /*
   * GNU DWARF 1 extensions
   */
  .debug_srcinfo   0 : { *(.debug_srcinfo) }
  .debug_sfnames   0 : { *(.debug_sfnames) }
  /*
   * DWARF 1.1 and DWARF 2
   */
  .debug_aranges   0 : { *(.debug_aranges) }
  .debug_pubnames  0 : { *(.debug_pubnames) }
  /*
   * DWARF 2
   */
  .debug_info      0 : { *(.debug_info) }
  .debug_abbrev    0 : { *(.debug_abbrev) }
  .debug_line      0 : { *(.debug_line) }
  .debug_frame     0 : { *(.debug_frame) }
  .debug_str       0 : { *(.debug_str) }
  .debug_loc       0 : { *(.debug_loc) }
  .debug_macinfo   0 : { *(.debug_macinfo) }
  .debug_ranges    0 : { *(.debug_ranges) }
  /*
   * SGI/MIPS DWARF 2 extensions
   */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /*
   * Optional sections that may only appear when relocating.
   */
  /*
   * Optional sections that may appear regardless of relocating.
   */
  .version_info    0 : { *(.version_info) }
  .boffs           0 : { KEEP (*(.boffs)) }
}

