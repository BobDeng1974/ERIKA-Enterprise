/* ----------------------------------------------------------------------------
 * Target: TriCore RAM (DSPR & PSPR) memory
 *
 * For a description of the different statements in this file, please refer
 * to the D-LD Linker User's Manual.
 * ------------------------------------------------------------------------- */

/* When you work directly on RAM you don't need copy tables */
/* -Xgenerate-copytables */

/* Start-up Program Flash Memory */
__PMU_PFLASH_STARTUP_BEGIN = 0x80000000;
__PMU_PFLASH_STARTUP_SIZE  = 1k;
/* Program Flash Memory (PFLASH0) */
__PMU_PFLASH_BEGIN = 0x80004000;
__PMU_PFLASH_SIZE  = 1984k;
/* Program Flash Memory (PFLASH1) */ 
__PMU_PFLASH1_BEGIN = 0x80200000;
__PMU_PFLASH1_SIZE = 2M;
/* Data Flash Memory (DFLASH0) */ 
__PMU_DFLASH0_BEGIN = 0xAF000000;
__PMU_DFLASH0_SIZE = 1M;
/* Data Flash Memory (DFLASH0_1) */ 
__PMU_DFLASH0_1_BEGIN = 0xAF100000;
__PMU_DFLASH0_1_SIZE = 16K;
/* Data Flash Memory (DFLASH1) */ 
__PMU_DFLASH1_BEGIN = 0xAF110000;
__PMU_DFLASH1_SIZE = 64K;
/* Boot ROM (BROM) */ 
__BROM_BEGIN = 0x8FFF8000;
__BROM_SIZE = 32K;
/* Scratch-Pad RAM (PSPR) */ 
__PMI_PSPR_BEGIN = 0xC0000000;
__PMI_PSPR_SIZE = 24K;
/* Local Data RAM (DSPR) */ 
__DMI_DSPR_BEGIN = 0xD0000000;
__DMI_DSPR_SIZE = 112K;
/* Local Data RAM (DSPR) */ 
__LMU_SRAM_BEGIN = 0x90000000;
__LMU_SRAM_SIZE = 32K;

/* CSA list size (I cannot handle default value: it must to be passed by
   command line) */
/* __CSA_SIZE = (CSA_SIZE != 0) ? __CSA_SIZE : 8k; */
/* User stack Size (I cannot handle default value: it must to be passed by
   command line) */ 
/* __USTACK_SIZE = (USTACK_SIZE != 0) ? __USTACK_SIZE : 2K; */
/* Interrupt Stack Size -Unused- */
/* __ISTACK_SIZE = (ISTACK_SIZE != 0) ? __ISTACK_SIZE : 0K; */
__ISTACK_SIZE = 0K;
/* Heap size -Unused- */
__HEAP_SIZE = 0;

MEMORY
{
  /* - 0x(8)A0000000--0x(8)A000001F ABM Header Start */
  /* - 0x(8)A0000020 Boot Address */
  /* - 0x(A)80000020--0x(A)80017FFF Code Application Pattern */
  /* - Program Flash Memory for startup (PFLASH0) */
  PMU_PFLASH_STARTUP: org = 0x80000000, len = 1k
  /* ! COMMENTED SUPPORT FOR ABS18 ADRESSING IN FLASH ! */
  /* - Program Flash Memory for 18 bit absolute addressing (PFLASH0) */
  /* PMU_PFLASH_ABS18  (rx!p): org = 0x80000400, len = 15k */
  /* - Program Flash Memory (PFLASH0) I take 16k for absolute 18 bit
       addressing */
  /* PMU_PFLASH  (rx!p):  org = 0x80004000, len = 1984k */
  /* ! END COMMENT ! */
  PMU_PFLASH:       org = 0x80000400, len = 1999k
  /* - Program Flash Memory (PFLASH1) */
  PMU_PFLASH1:      org = 0x80200000, len = 2M
  /* - Data Flash Memory (DFLASH0) */ 
  PMU_DFLASH0:      org = 0xAF000000, len = 1M
  /* - Data Flash Memory (DFLASH0_1) */
  PMU_DFLASH0_1:    org = 0xAF100000, len = 16K
  /* - Data Flash Memory (DFLASH1) */ 
  PMU_DFLASH1:      org = 0xAF110000, len = 64K
  /* - Boot ROM (BROM) */ 
  BROM:             org = 0x8FFF8000, len = 32K

  /* - Scratch-Pad RAM (PSPR) (0x2500 + 0x3B00 = 24k) */
  PMI_PSPR_STARTUP: org = 0xC0000000, len = 0x2500
  PMI_PSPR:         org = 0xC0002500, len = 0x3B00
  /* - Local Data Scratch-Pad RAM (DSPR) */
  DMI_DSPR:         org = 0xD0000000, len = 112K
  /* - Global Data RAM */ 
  LMU_SRAM:         org = 0x90000000, len = 32K
}

/* The SECTIONS command specifies where and how the linker should locate
 * different modules of the system.
 * ------------------------------------------------------------------------ */

SECTIONS
{
  /* Some sections below are used only by certain targets supported by
   * Diab Data, or only for certain options. If not used by your
   * target, they will be ignored.
   *
   * Section names beginning with ".j_" are for the Diab Data FastJ
   * compiler for the Java language.
   *
   * The first GROUP contains code and constant data, and is
   * allocated in the "rom" area.
   */

  GROUP : {
    .startup (TEXT) : {
      __startup_code_start = .;
      KEEP (*(.startup_code))
      KEEP (*(ee_kernel_start))
      . = ALIGN(8);
      __startup_code_end = .;
    }
  }  > PMI_PSPR_STARTUP
  

  /*
   * Allocate trap and interrupt vector tables.
   */
  GROUP : { 
    .traptab (TEXT) : {
        __traptab_start = .;
        KEEP(*(.traptab))   /* Section for trap table */ 
        __traptab_end = .;
        . = ALIGN(8);
    }
  } > PMI_PSPR_STARTUP

  GROUP : {
    .inttab (TEXT) : {
      __inttab_start = .;
      KEEP(*(.inttab))      /* Section for interrupt table */ 
      __inttab_end = .;
      . = ALIGN(8);
    }
  }  > PMI_PSPR_STARTUP

  /*
   * Allocate .text and other read-only sections.
   */
  GROUP : {
    .cramtext (TEXT) : {
      *(.cramtext)
    }
  } > PMI_PSPR_STARTUP

  GROUP : {
    .text (TEXT) : {
      *(.text)
      *(.frame_info)
      *(.j_class_table)
      *(.init)
      *(.fini)
      . = ALIGN(8);
    }

    .ctors (CONST) ALIGN(4) : {
      ctordtor.o(.ctors)
      *(.ctors)
    }

    .dtors (CONST) ALIGN(4) : {
      ctordtor.o(.dtors)
      *(.dtors)
    }
  } > PMI_PSPR

  GROUP : {
    .zrodata (CONST) : {
      *(.zrodata)
    }

    .zdata (DATA) : {
      *(.zdata)
    }

    .srodata (CONST) : {
      *(.srodata)
      *(.ldata)
      *(.lbss)  /* Workaround to get rid of linker warning for external const definitions */
    }

    _LITERAL_DATA_ = SIZEOF(.srodata) ? (ADDR(.srodata) + 32k) : ((ADDR(.srodata) & 0xF0000000) + 32k);
    _SMALL_DATA2_  = _LITERAL_DATA_;

    .sdata (DATA) : {
      *(.sdata)
    }

    .sbss (BSS) : {
      *(.sbss)
    }

    _SMALL_DATA_ = SIZEOF(.sdata) ? (ADDR(.sdata) + 32k) : ((ADDR(.sdata) & 0xF0000000) + 32k);
    __A0_MEM = _SMALL_DATA_;

    .rodata (CONST) : {
      *(.rodata)
    }

    /* Usually You don't need neither the stacks table for stack filling, but
       DCC doesn't support array range initialization */
    .ee_stacks_table (CONST) : {
      ee_stacks_table = .;
      STORE(ADDR(ee_kernel_stack), 4)
      STORE(SIZEOF(ee_kernel_stack), 4)
      STORE(-1, 4)
      STORE(-1, 4)
      . = ALIGN(8);
    }

    .data : {
      *(.data)
    }

    .bss (BSS) : {
      *(.bss)
    }

    /*
     * Section for ustack
     */  
    .ustack : {
      . = ALIGN(8);
      __USTACK_BEGIN = .;
      . += __USTACK_SIZE;
      . = ALIGN(8);
      __USTACK = .;
      __USTACK_END = .;
    }

    /*
     * Section for istack
     */  
    .istack : {
      . = ALIGN(8);
      __ISTACK_BEGIN = .;
      . += __ISTACK_SIZE;
      . = ALIGN(8);
      __ISTACK = .;
      __ISTACK_END = .;
    }

    /* ERIKA Kernel Stacks  */
    ee_kernel_stack ALIGN(8) : {
      ee_sstack_kernel = .;
      KEEP(*(ee_kernel_stack))
      . += 15;
      . = ALIGN(8);
      ee_estack_kernel = .;
    }

    /*
     * Section for heap
     */  
    .heap : {
      . = ALIGN(8);
      /* Default DIAB label */
      __HEAP_START = .;
      __HEAP_BEGIN = .;
      . += __HEAP_SIZE;
      . = ALIGN(8);
      __HEAP_END = .;
    }

    /*
     * Section for CSA
     */  
    .csa : {
      . = ALIGN(64);
      __CSA_BEGIN = .;
      . += __CSA_SIZE;
      . = ALIGN(64);
      __CSA_END = .;
    }
  } > DMI_DSPR

/* Make sure CSA, stack and heap addresses are properly aligned.  */
ASSERT((__CSA_BEGIN & 0x3f) == 0 , "illegal CSA start address")
ASSERT((__CSA_SIZE & 0x3f) == 0 , "illegal CSA size")
ASSERT((__ISTACK & 7) == 0 , "ISTACK not doubleword aligned")
ASSERT((__USTACK & 7) == 0 , "USTACK not doubleword aligned")
ASSERT((__HEAP_END & 7) == 0 , "HEAP not doubleword aligned")

_start_addr = 0x80000020;
}

